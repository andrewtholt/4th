
Glossary

This glossary contains all of the word definitions used in 
version 3.62 of 4tH. The definitions are presented in order of 
their ASCII sort. Availability of the word in the appropriate 
ANS-Forth wordset is listed. This does not mean any conformance 
to the ANS-Forth definition.

Pronunciation: Natural-language pronunciation if it differs from 
English.

Include: Following library file provides this word.

Compiles to: Describes the transformation of the word to token(s) 
without peephole optimization. Compiler directives will lack this 
section.

Syntax: Describes definition characteristics if non-conformance 
should lead to a compilation error.


+------------+-------------------------------------------------+
|  <char>    | Character                                       |
+------------+-------------------------------------------------+
| <string>   | String constant, delimited by spaces            |
+------------+-------------------------------------------------+
| <literal>  | Expression which compiles to LITERAL (n)        |
+------------+-------------------------------------------------+
|  <name>    | String of characters, stored in the symboltable |
+------------+-------------------------------------------------+
|  <space>   | Space character                                 |
+------------+-------------------------------------------------+
|  <word>    | Any valid 4tH word.                             |
+------------+-------------------------------------------------+


Compiler: Describes special actions the compiler takes when 
compiling this word.

Stack effects: Describes the action of the tokens on the 
parameter stack at runtime. The symbols indicate the order in 
which input parameters have been placed on the stack. Two dashes 
indicate the execution point. Any parameters left on the stack 
are listed. In this notation, the top of the stack is to the 
right.


+-------+--------------------------+-------------------+
| n     | 32 bits signed number    |                   |
+-------+--------------------------+-------------------+
| c     | 8 bits character         |                   |
+-------+--------------------------+-------------------+
| f     | boolean flag             |                   |
+-------+--------------------------+-------------------+
| fam   | file access method       |                   |
+-------+--------------------------+-------------------+
| h     | file handle (stream)     |                   |
+-------+--------------------------+-------------------+
| d     | double number (2 cells)  |                   |
+-------+--------------------------+-------------------+
| sp    | stack pointer            | Stack Area        |
+-------+--------------------------+-------------------+
| x     | address of a cell        | Variable Area     |
+-------+--------------------------+-------------------+
| addr  | address of a character   | Character Segment |
+-------+--------------------------+-------------------+
| xt    | execution token          | Code Segment      |
+-------+--------------------------+-------------------+


Floating: Describes the action of floating point words on the 
floating point stack at runtime. The symbols[footnote:
'r' stands for real number.
] indicate the order in which input parameters have been placed 
on the stack. Two dashes indicate the execution point. Any 
parameters left on the floating point stack are listed. In this 
notation, the top of the stack is to the right.

Forth: Describes the deviation of 4tH from ANS-Forth and gives 
suggestions for porting Forth programs.




! CORE

Pronunciation: store

Compiles to: ! (0)

Stack effects: n x ---

Stores n in the variable at address x.



# CORE

Pronunciation: number-sign

Compiles to: # (0)

Stack effects: n1 --- n2

Forth: In Forth a double number is required.

Generate from n1 the next ASCII character which is placed in an 
output string, stored in PAD. Result n2 is the quotient after the 
division by BASE, and is remained for further processing. Used 
between <# and #>.



#! 4TH

Syntax: #!<space><string>

The remainder of the line is discarded. This word is used to 
start a 4tH source program from a Unix type shell. An alias for 
\.



#> CORE

Pronunciation: number-sign-greater

Compiles to: #> (0)

Stack effects: n1 --- addr n2

Forth: In Forth a double number is required.

Terminates numeric output conversion by dropping n1, leaving the 
address in PAD and character count n2 suitable for TYPE.



#S CORE

Pronunciation: number-sign-s

Compiles to: #S (0)

Stack effects: n1 --- n2

Forth: In Forth a double number is required.

Generates ASCII text in PAD by the use of # until a zero number 
n2 results. Used between <# and #>.



#TIB CORE EXT

Pronunciation: number-t-i-b

Include: obsolete.4th

Stack effects: --- x

X is the address of a cell containing the number of characters in 
the terminal input buffer (see /TIB).



' CORE

Pronunciation: tick

Compiles to: LITERAL (<argument of symbol>)

Syntax: '<space><name>

Stack effects: --- x | xt | n

Forth: In Forth you can determine the address of variables, 
constants, etc. In 4tH the contents of the symboltable entry is 
returned. Of course the token addresses of built-in primitives 
cannot be determined either. E.g. use

  : _+ + ; ' _+

  instead of

  ' +

Compile the value contents of the symboltable entry identified as 
symbol <name> as a literal.



( CORE   FILE

Pronunciation: paren

Syntax: (<space><string>)

Ignore a comment that will be delimited by a right parenthesis. 
May occur inside or outside a colon-definition. A blank after the 
leading parenthesis is required.



(ERROR) 4TH

Compiles to: LITERAL (<largest negative integer>)

Stack effects: --- n

Returns 4tHs internal error-flag. This number cannot be printed. 
Usually -2^31.



) 4TH

Compiles to: EQ0 (0)

  0BRANCH (<address of THROW>)

  LITERAL (<M4ASSERT>)

  THROW (0)

Stack effects: f ---

Forth: Similar constructions are available in GForth and 
Win32Forth.

If flag f is FALSE, the program will terminate with an error. Its 
compilation is dependant on the presence of [ASSERT] (see: 
[ASSERT] and ASSERT().



* CORE

Pronunciation: star

Compiles to: * (0)

Stack effects: n1 n2 --- n3

Leave the product n3 of two numbers n1 and n2.



*/ CORE

Pronunciation: star-slash

Compiles to: */ (0)

Stack effects: n1 n2 n3 --- n4

Leave the ratio n4 = n1*n2/n3.



*/MOD CORE

Pronunciation: star-slash-mod

Compiles to: >R (0)

  * (0)

  R> (0)

  /MOD (0)

Stack effects: n1 n2 n3 --- n4 n5

Leave the quotient n5 and remainder n4 of the operation n1*n2/n3.



*CONSTANT 4TH

Syntax: <literal><space>*CONSTANT<space><name>

Compiler: The previously compiled literal is taken as an argument 
for *CONSTANT. The instruction pointer is decremented, actually 
deleting the literal.

A defining word used to create word <name>. When <name> is later 
executed, it will multiply the top of the stack with the value of 
<literal>.



+ CORE

Pronunciation: plus

Compiles to: + (0)

Stack effects: n1 n2 --- n3

Leave the sum n3 of n1+n2.



+! CORE

Pronunciation: plus-store

Compiles to: +! (0)

Stack effects: n x ---

Add n to the value in variable at address x.



+CONSTANT 4TH

Syntax: <literal><space>+CONSTANT<space><name>

Compiler: The previously compiled literal is taken as an argument 
for +CONSTANT. The instruction pointer is decremented, actually 
deleting the literal.

A defining word used to create word <name>. When <name> is later 
executed, it will add the value of <literal> on the top of the 
stack.



+FIELD FACILITY EXT

Syntax: 
STRUCT<space><literal><space>+FIELD<space><name><space>END-STRUCT<space><name>

Compiler: Take two previous compiled literals. The last literal 
is added to the first and recompiled. The first literal is the 
value of a named +CONSTANT. The instruction pointer does not 
change.

Create a field for STRUCTURE implementations. The created 
fieldname is an +CONSTANT that memorizes the current offset (see: 
+FIELD, /FIELD, STRUCT, END-STRUCT). 



+LOOP CORE

Pronunciation: plus-loop

Compiles to: +LOOP (<address of matching DO token>)

Syntax: DO<space>..<space>+LOOP

Stack effects: n ---

Used in the form DO .. n1 +LOOP. At runtime, +LOOP selectively 
controls branching back to the corresponding DO based on n1, the 
loop index and the loop limit. The increment n1 is added to the 
index and the total compared to the limit. The branch back to DO 
occurs until the new index is equal to or greater than the limit 
(n > 0), or until the new index is less than the limit (n < 0). 
Upon exiting the loop, the parameters are discarded and execution 
continues ahead.



+PLACE COMUS

Compiles to: COUNT (0)

  + (0)

  PLACE (0)

Stack effects: addr1 n addr2 ---

Copies the string at address addr1 with count n to address addr2.



+X/STRING XCHAR EXT

Include: xchar.4th

Stack effects: addr1 n1 --- addr2 n2

Step forward by one xchar in the buffer defined by addr1 n1. 
addr2 n2 is the remaining buffer after stepping over the first 
xchar in the buffer. 



, CORE

Pronunciation: comma

Compiles to: , (<literal>)

Syntax: <literal><space>,

Compiler: The previously compiled literal is changed into a NOOP 
instruction. The instruction pointer is not incremented.

Forth: Forth pops a value from the stack. This is not possible in 
4tH. Instead the previously compiled literal has its codefield 
changed to NOOP.

Store the literal into the next available location.



," COMUS

Compiles to: ," (<address of string constant>)

Syntax: ,"<space><string>"

Forth: Compilation characteristics are quite different. 4tH 
compiles only the address, Forth compiles the entire string.

Compile the string, delimited by " in the String Segment and 
leave the offset as the address of a string constant (see: @C).



,| 4TH

Compiles to: ," (<address of string constant>)

Syntax: ,|<space><string>|

Compile the string, delimited by | in the String Segment and 
leave the offset as the address of a string constant (see: @C).



- CORE

Pronunciation: minus

Compiles to: - (0)

Stack effects: n1 n2 --- n3

Leave the difference of n1 - n2 in n3.



-> 4TH

Compiler: The instruction pointer is not incremented. In fact, -> 
is a dummy.

Syntax: <name><space>-><space><name>

Separation between a structure and its member. 



-ROT COMUS

Compiles to: ROT (0)

  ROT (0)

Stack effects: n1 n2 n3 --- n3 n1 n2

Rotate top stack item below the next two items.



-TRAILING STRING

Pronunciation: dash-trailing

Compiles to: -TRAILING (0)

Stack effects: addr n1 --- addr n2

Adjusts the character count n1 of a string beginning address to 
suppress the output of trailing blanks, i.e. the characters from 
addr+n1 to addr+n2 are blanks.



-TRAILING-GARBAGE XCHAR EXT

Include: anstools.4th

Stack effects: addr n1 --- addr n2

Examine the last xchar in the string addr n1 - if the encoding is 
correct and it represents a full xchar, n2 equals n1, otherwise, 
n2 represents the string without the last (garbled) xchar. 
-TRAILING-GARBAGE does not change this garbled xchar. 

. CORE

Pronunciation: dot

Compiles to: . (0)

Stack effects: n ---

Print a number to the current output device, converted according 
to the numeric BASE. A trailing blank follows.



." CORE

Pronunciation: dot-quote

Compiles to: ." (<address of string constant>)

Syntax: ."<space><string>"

Compiles string in the String Segment with an execution procedure 
to transmit the string to the selected output device.



.( CORE EXT

Pronunciation: dot-paren

Compiles to: ." (<address of string constant>)

Syntax: .(<space><string>)

Compiles string in the String Segment with an execution procedure 
to transmit the string to the selected output device. An alias 
for .".



.R CORE EXT

Pronunciation: dot-r

Compiles to: .R (0)

Stack effects: n1 n2 ---

Print the number n1 right aligned in a field whose width is n2 to 
the current output device. No following blank is printed.



.S TOOLS

Pronunciation: dot-s

Include: anstools.4th

Stack effects: ---

Copy and display the values currently on the data stack.



.| 4TH

Compiles to: ." (<address of string constant>)

Syntax: .|<space><string>|

Compiles string in the String Segment with an execution procedure 
to transmit the string to the selected output device.



/ CORE

Pronunciation: slash

Compiles to: / (0)

Stack effects: n1 n2 --- n3

Leaves the quotient n3 of n1/n2.



/CELL COMUS

Compiles to: LITERAL (<size of a cell>)

Stack effects: --- n

Returns the size of a cell in address units.



/CHAR COMUS

Compiles to: LITERAL (<size of char>)

Stack effects: --- n

Returns the size of a character in address units.



/CONSTANT 4TH

Syntax: <literal><space>/CONSTANT<space><name>

Compiler: The previously compiled literal is taken as an argument 
for /CONSTANT. The instruction pointer is decremented, actually 
deleting the literal.

A defining word used to create word <name>. When <name> is later 
executed, it will divide the top of the stack by the value of 
<literal>.



/FIELD 4TH

Syntax: 
STRUCT<space><literal><space>/FIELD<space>END-STRUCT<space><name>

Compiler: Take two previous compiled literals. The last literal 
is compared to the first and the larger one of the two is 
recompiled. The instruction pointer does not change.

Create a field for UNION implementations (see: +FIELD, /FIELD, 
STRUCT, END-STRUCT). 



/MOD CORE

Pronunciation: slash-mod

Compiles to: /MOD (0)

Stack effects: n1 n2 --- n3 n4

Leave the remainder n3 and quotient n4 of n1/n2.



/PAD 4TH

Compiles to: LITERAL (<size of PAD>)

Stack effects: --- n

Forth: Equivalent to:

  : /PAD S" /PAD" ENVIRONMENT? DROP ;

Returns the size of PAD.



/STRING STRING

Pronunciation: slash-string

Compiles to: SWAP (0)

  OVER (0)

  - (0)

  >R (0)

  + (0)

  R> (0)

Stack effects: addr1 n1 n2 --- addr2 n3

Adjust the character string at addr1 by n2 characters. The 
resulting character string, specified by addr2 n3 , begins at 
addr1 plus n2 characters and is n1 minus n characters long.



/TIB 4TH

Compiles to: LITERAL (<size of TIB>)

Stack effects: --- n

Returns the size of the terminal input buffer.



0< CORE

Pronunciation: zero-less

Compiles to: 0< (0)

Stack effects: n --- f

Leave a TRUE flag if number n is less than zero (negative), 
otherwise leave a FALSE flag in f.



0<> CORE EXT

Pronunciation: zero-not-equals

Compiles to: 0<> (0)

Stack effects: n --- f

Leave a TRUE flag if number n is not equal to zero, otherwise 
leave a FALSE flag in f.



0= CORE

Pronunciation: zero-equals

Compiles to: 0= (0)

Stack effects: n --- f

Leave a TRUE flag if number n is equal to zero, otherwise leave a 
FALSE flag in f.



0> CORE EXT

Pronunciation: zero-greater

Compiles to: 0> (0)

Stack effects: n --- f

Leave a TRUE flag if number n is greater than zero (positive), 
otherwise leave a FALSE flag in f.



1+ CORE

Pronunciation: one-plus

Compiles to: +LITERAL (1)

Stack effects: n --- n+1

Increment n by 1.



1- CORE

Pronunciation: one-minus

Compiles to: +LITERAL (-1)

Stack effects: n --- n-1

Decrement n by 1.



2! CORE

Pronunciation: two-store

Include: anscore.4th

Stack effects: n1 n2 x ---

Store the cell pair n1 n2 at x, with n2 at x and n2 at the next 
consecutive cell.



2* CORE

Pronunciation: two-star

Compiles to: *LITERAL (2)

Stack effects: n --- n*2

Multiply n by 2. Performs a left shift.



2/ CORE

Pronunciation: two-slash

Compiles to: 2/ (0)

Stack effects: n --- n/2

Divide n by 2. Performs a right shift.



2>R CORE EXT

Pronunciation: two-to-r

Compiles to: >R (0)

  >R (0)

Stack effects: n1 n2 ---

Forth: Forth swaps both values before transfering them to the 
return stack.

Transfer cell pair n1 n2 to the return stack.



2@ CORE

Pronunciation: two-fetch

Include: anscore.4th

Stack effects: x --- n1 n2

Fetch the cell pair n1 n2 stored at x. n2 is stored at x and n1 
at the next consecutive cell.



2DROP CORE

Pronunciation: two-drop

Compiles to: DROP (0)

  DROP (0)

Stack effects: n1 n2 ---

Drop cell pair n1 n2 from the stack.



2DUP CORE

Pronunciation: two-dupe

Compiles to: OVER (0)

  OVER (0)

Stack effects: n1 n2 --- n1 n2 n1 n2

Duplicate cell pair n1 n2.



2NIP TOOLBELT

Compiles to: ROT (0)

  DROP (0)

  ROT (0)

  DROP (0)

Stack effects: n1 n2 n3 n4 --- n3 n4

Drop the third and fourth items on the stack.



2OVER CORE

Pronunciation: two-over

Include: anscore.4th

Stack effects: n1 n2 n3 n4 --- n1 n2 n3 n4 n1 n2

Copy cell pair n1 n2 to the top of the stack.



2R> CORE EXT

Pronunciation: two-r-from

Compiles to: R> (0)

  R> (0)

Stack effects: --- n1 n2

Forth: Forth swaps both values after transfering them from the 
return stack.

Transfer cell pair n1 n2 from the return stack.



2R@ CORE EXT

Pronunciation: two-r-fetch

Compiles to: R> (0)

  I (0)

  OVER (0)

  >R (0)

Stack effects: --- n1 n2

Forth: Forth swaps both values after transfering them from the 
return stack.

Copy cell pair n1 n2 from the return stack.



2ROT DOUBLE EXT

Pronunciation: two-rote

Include: anscore.4th

Stack effects: n1 n2 n3 n4 n5 n6 --- n3 n4 n5 n6 n1 n2

Rotate the top three cell pairs on the stack bringing cell pair 
n1 n2 to the top of the stack.



2SWAP CORE

Pronunciation: two-swap

Compiles to: ROT (0)

  >R (0)

  ROT (0)

  R> (0)

Stack effects: n1 n2 n3 n4 --- n3 n4 n1 n2

Exchange the top two cell pairs.



4TH# 4TH

Compiles to: LITERAL (<4tH version in hexadecimal>)

Stack effects: --- n

Constant containing the 4tH version in hexadecimal.



: CORE

Pronunciation: colon

Compiles to: BRANCH (<address of matching ; token>)

Syntax: :<space><name>..<space>;

Creates a subroutine defining <name> as equivalent to the 
following sequence of 4tH word definitions until the next ;.



:NONAME CORE EXT

Pronunciation: colon-no-name

Compiles to: LITERAL (<address of next BRANCH>)

  BRANCH (<address of matching ; token>)

Syntax: :NONAME<space>..<space>;

Stack effects: --- xt

Create an execution token xt and compile the current definition. 
The execution semantics of xt will be determined by the words 
compiled into the body of the definition. This definition can be 
executed later by using xt EXECUTE.



:REDO 4TH

Compiles to: BRANCH (<address of matching ; token>)

  LITERAL (<original value>) | VARIABLE (<original value>)

Syntax: :REDO<space><name><space>..<space>;

Create an subroutine <name> that first pushes the original value 
of <name> on the stack. The words after <name> determine what the 
actual execution behavior will be (see: DOES>).



:TOKEN 4TH

Compiles to: BRANCH (<address of matching ; token>)

Syntax: :TOKEN<space><name><space>..<space>;

Forth: The equivalent in Forth is:

  :noname ; constant <name>

Create an execution token <name> and compile the current 
definition. The execution semantics of <name> will be determined 
by the words compiled into the body of the definition. This 
definition can be executed later by using <name> EXECUTE.



; CORE

Pronunciation: semi-colon

Compiles to: EXIT (0)

Syntax: See :

Terminate a colon definition. At runtime, return to the calling 
word by popping a token-address from the return stack.



;] COMP.LANG.FORTH

Compiles to: EXIT (0)

Syntax: See [:

Forth: Several Forths support this word, e.g. gForth, iForth and 
VFX Forth.

Ends the current nested definition, and resumes compilation to 
the previous current definition (if any).



< CORE

Pronunciation: less-than

Compiles to: < (0)

Stack effects: n1 n2 --- f

Leave a TRUE flag if n1 is less than n2; otherwise leave a FALSE 
flag in f.



<# CORE

Pronunciation: less-number-sign

Compiles to: <# (0)

Forth: In Forth a double number is required.

Setup for pictured numeric output formatting in PAD using the 
words <#, #, #S, SIGN, HOLD, #>.



<> CORE EXT

Pronunciation: not-equals

Compiles to: <> (0)

Stack effects: n1 n2 --- f

Leave a TRUE flag if n1 does not equal n2; otherwise leave a 
FALSE flag in f.



<= 4TH

Compiles to: > (0)

  0= (0)

Stack effects: n1 n2 --- f

Leave a TRUE flag if n1 is less or equal than n2; otherwise leave 
a FALSE flag in f.



= CORE

Pronunciation: equals

Compiles to: = (0)

Stack effects: n1 n2 --- f

Leave a TRUE flag if n1 equals n2; otherwise leave a FALSE flag 
in f.



> CORE

Pronunciation: greater-than

Compiles to: > (0)

Stack effects: n1 n2 --- f

Leave a TRUE flag if n1 is greater than n2; otherwise leave a 
FALSE flag in f.



>= 4TH

Compiles to: < (0)

  0= (0)

Stack effects: n1 n2 --- f

Leave a TRUE flag if n1 is greater or equal than n2; otherwise 
leave a FALSE flag in f.



>BODY CORE

Pronunciation: to-body

Compiles to: ENVIRON (<address of FIRST>)

  + (0)

Stack effects: n --- x

Forth: In Forth, >BODY works with every CREATEd datatype.

n is the ticked value of a VARIABLE, VALUE, DEFER or FILE. >BODY 
returns its address in the Variable Area.



>FLOAT FLOATING

Pronunciation: to-float

Include: ansfpio.4th

  zenfpio.4th

  fpin.4th

Stack effects: addr n --- f

Floating: --- r

An attempt is made to convert the string specified by addr and n 
to internal floating-point representation. If the string 
represents a valid floating-point number in the syntax ”mantissa 
(with optional exponent)”, its value r and true are returned. If 
the string does not represent a valid floating-point number only 
false is returned. 



>IN CORE

Pronunciation: to-in

Compiles to: LITERAL (<address of >IN>)

Stack effects: --- x

A variable containing the address within the Character Segment 
from which the next text will be parsed. PARSE uses and moves the 
value of >IN.



>NUMBER CORE

Pronunciation: to-number

Include: tonumber.4th

  todbl.4th

Stack effects: n1 a1 n2 --- n3 a2 n4

  d1 a1 n1 --- d2 a2 n4

n3|d2 is the unsigned result of converting the characters within 
the string specified by a1 n2 into digits, using the number in 
BASE, and adding each into n1|d1 after multiplying n1|d2 by the 
number in BASE. Conversion continues left-to-right until a 
character that is not convertible, including any + or -, is 
encountered or the string is entirely converted. a2 is the 
location of the first unconverted character or the first 
character past the end of the string if the string was entirely 
converted. n4 is the number of unconverted characters in the 
string. An ambiguous condition exists if n3|d2 overflows during 
the conversion. 



>R CORE

Pronunciation: to-r

Compiles to: >R (0)

Stack effects: n ---

Remove n from the stack and place it on the return stack. Use 
should be balanced with R> in the same definition.



>STRING 4TH

Compiles to: OVER (0)

  PLACE (0)

Stack effects: a n ---

Convert a string identified by address a and length n to a 
terminated string at address a. Use only on string variables.



? TOOLS

Pronunciation: question

Compiles to: @ (0)

  . (0)

Stack effects: x ---

Print the value contained in the variable at address x in free 
format according to the current BASE.



?DO CORE EXT

Pronunciation: question-do

Compiles to: ?DO (0)

Syntax: ?DO<space>..<space>+LOOP

  ?DO<space>..<space>LOOP

Stack effects: n1 n2 ---

If n1 is equal to n2, continue execution at LOOP or +LOOP. 
Otherwise set up loop control parameters with index n2 and limit 
n1 and continue executing immediately following ?DO. Anything 
already on the return stack becomes unavailable until the loop 
control parameters are discarded.



?DUP CORE

Pronunciation: question-dupe

Include: pickroll.4th

Stack effects: n --- 0 | n n

Duplicate n if it is non-zero.



@ CORE

Pronunciation: fetch

Compiles to: @ (0)

Stack effects: x --- n

Leave the contents n of the variable at address x on the stack.



@C CROSS EXT

Compiles to: @C (0)

Stack effects: xt --- n | addr

Forth: In Forth the word @ can also be used to fetch values from 
the dictionary. Due to 4tHs internal structure this is not 
possible.

Leave the contents n of the parameter field of token address xt 
on the stack. If n contains an string constant compiled by ,” it 
is copied to the PAD. Its address is returned as addr.



@GOTO 4TH

Syntax: @GOTO<space><string>

The remainder of the line is discarded. This word is used to 
start a 4tH source program from a MS type shell. An alias for \.



ABORT CORE

Forth: In Forth the behaviour of ABORT is different from QUIT (-1 
THROW). In 4tH it doesn't really matter which one you use.

An alias for QUIT.



ABORT" CORE

Pronunciation: abort-quote

Compiles to: 0BRANCH (<address of QUIT>)

  LITERAL (stdout)

  USE (0)

  .” (<address of string constant>)

  CR (0)

  QUIT (0)

Syntax: ABORT”<space><string>”

Stack effects: n ---

Forth: In Forth the behaviour of ABORT” is different from QUIT 
(-2 THROW). 

Remove n from the stack. If any bit of n is not zero, display the 
string and set the program counter to the end of the program. 
Effectively quits execution.



ABS CORE

Pronunciation: abs

Compiles to: ABS (0)

Stack effects: n1 --- n2

Leave the absolute value of n1 as n2.



ACCEPT CORE

Compiles to: ACCEPT (0)

Stack effects: addr n1 --- n2

Forth: In Forth no null character is appended.

Read n1 characters from the current input device to address addr. 
If input is read from the terminal CR will terminate the input 
stream. All other devices will terminate reading when an EOF 
occurs. In all cases input will end when n1 characters have been 
read. A null character is added to the end of the input when 
reading from the keyboard. The number n2 represents the number of 
characters actually read.



AGAIN CORE EXT

Compiles to: BRANCH (<address of the token following BEGIN>)

Syntax: BEGIN<space>..<space>AGAIN

At runtime, AGAIN forces execution to return to the corresponding 
BEGIN. Execution cannot leave this loop. AGAIN is an alias for 
REPEAT.



AKA 4TH

Syntax: AKA<space><word name><space><name>

Create a word <name> with the same compilation and execution 
semantics as the existing word <word name>. The word <word name> 
has to be user defined, a built-in constant or a word that 
compiles to a single token. Flow control words, preprocessor[footnote:
4tHs internal preprocessor, not the external preprocessor PP4tH. 
External preprocessor words are not recognized by 4tH at all, so 
they can't be 'AKA'ed anyway.
] words, defining words and inline macros cannot be 'AKA'ed. 



ALIAS 4TH

Compiles to: TO (<variable address>)

Stack effects: xt ---

Syntax: ALIAS<space><name>

Store xt in the value identified by name. ALIAS is an alias for 
IS, but does not require a previously defined DEFER.



ALIGN CORE

Compiler: The instruction pointer is not incremented. In fact, 
ALIGN is a dummy.

If the dataspace pointer is not aligned, reserve enough space to 
align it.



ALIGNED CORE

Compiler: The instruction pointer is not incremented. In fact, 
ALIGNED is a dummy.

Stack effects: n --- n

n is the first aligned address greater than or equal to n.



ALLOCATE MEMORY

Include: ansmem.4th

  memchar.4th

  memcell.4th

Stack effects: n --- addr f

Allocate n address units of contiguous data space. The initial 
content of the allocated space is undefined. If the allocation 
succeeds, addr is the aligned starting address of the allocated 
space and f is false. If the operation fails, addr does not 
represent a valid address and f is true.



AND CORE

Compiles to: AND (0)

Stack effects: n1 n2 --- n3

Leave the bitwise logical AND of n1 AND n2 as n3.



APP 4TH

Compiles to: LITERAL (<application variable>)

Stack effects: --- x

This word returns the variable address x in the Variable Area to 
an array of application specific variables. If APP equals FIRST 
no application specific variables have been defined.



APPEND 4TH

Compiles to: LITERAL (<fam>)

Stack effects: --- fam

This will leave a file access method modifier on the stack, 
signalling that output will be appended. Must be added to another 
file access modifier. Used in combination with OUTPUT.



ARGN 4TH

Compiles to: ARGN (0)

Stack effects: --- n

Returns the number of arguments that have been passed to 4tH 
(see: ARGS).



ARGS 4TH

Compiles to: ARGS (0)

Stack effects: n1 --- addr n2

Copies argument n1 to the PAD and leaves address addr and length 
n2 on the stack (see: ARGN).



ARRAY 4TH

Syntax: <literal><space>ARRAY<space><name>

Compiler: The previously compiled literal is taken as an argument 
for ARRAY. The instruction pointer is decremented, actually 
deleting the literal.

Forth: Roughly equivalent to:

  : ARRAY CREATE CELLS ALLOT ;

Allocate <literal> cells of contiguous data space beginning at 
<name> in the Integer Segment. The initial content of the 
allocated space is undefined.



ASSERT( 4TH

Syntax: ASSERT(<space><word>..<word><space>)

Forth: Similar constructions are available in GForth and 
Win32For.

Mark the beginning of an assertion. If assertions are disabled 
all words following upto ) are commented out (see: [ASSERT] and ) 
).



BASE CORE

Compiles to: LITERAL (<address of BASE>)

Stack effects: --- x

A variable containing the current number BASE used for input and 
output.



BEGIN CORE

Syntax: BEGIN<space>..<space>AGAIN

  BEGIN<space>..<space>WHILE<space>..<space>UNTIL

  BEGIN<space>..<space>WHILE<space>..<space>REPEAT

Forth: Within a BEGIN .. REPEAT construct, multiple WHILEs may be 
used as well, but additional words are necessary to complete the 
construct.

At runtime begin marks the start of a sequence that may be 
repetitively executed. It serves as a return point from the 
corresponding UNTIL, AGAIN or REPEAT. When executing UNTIL, a 
return to BEGIN will occur if the top of the stack is false; for 
AGAIN and REPEAT a return to BEGIN always occurs. Multiple WHILEs 
may be used.



B/BUF SOURCEFORGE

Include: ansblock.4th

  multiblk.4th

Stack effects: --- n

Returns the length of a block.



BIN FILE

Include: ansfile.4th

Stack effects: fam1 --- fam2

Modify file access method fam1 to additionally select a binary, 
i.e., not line oriented, file access method, giving access method 
fam2. Since 4tH does this automatically, BIN is a dummy.



BL CORE

Pronunciation: b-l

Compiles to: LITERAL (<ASCII value of space>)

Stack effects: --- c

A constant that leaves the ASCII value for "blank".



BLANK STRING

Compiles to: LITERAL (<ASCII value of space)

  FILL (0)

Stack effects: n addr ---

If n is greater than zero, store the character value for space in 
n consecutive character positions beginning at addr.



BLK BLOCK

Pronunciation: b-l-k

Include: ansblock.4th

  multiblk.4th

Stack effects: --- x

Forth: In Forth, a block cannot have the number zero. BLK 
contains the number of the block being interpreted.

x is the address of a cell containing the number of the 
mass-storage block currently cached. An ambiguous condition 
exists if a program directly alters the contents of BLK. 



BLOCK BLOCK

Include: ansblock.4th

  multiblk.4th

Stack effects: n --- addr

Addr is the address of the first character of the block buffer 
assigned to mass-storage block n. An ambiguous condition exists 
if u is not an available block number. If block n is already in a 
block buffer, addr is the address of that block buffer. If block 
n is not already in memory, unassign the block buffer. If the 
block in that buffer has been UPDATEd, transfer the block to mass 
storage and transfer block n from mass storage into that buffer. 
a-addr is the address of that block buffer. At the conclusion of 
the operation, the block buffer pointed to by addr is the current 
block buffer and is assigned to n.



BOUNDS COMUS

Compiles to: OVER (0)

  + (0)

  SWAP (0)

Stack effects: addr n --- addr addr+n

Convert a starting value and count into the form required for a 
DO or ?DO loop.



BUFFER BLOCK

Include: ansblock.4th

  multiblk.4th

Stack effects: n --- addr

Addr is the address of the first character of the block buffer 
assigned to mass-storage block n. An ambiguous condition exists 
if n is not an available block number. If block n is already in a 
block buffer, addr is the address of that block buffer. If block 
n is not already in memory, unassign the block buffer. If the 
block in that buffer has been UPDATEd, transfer the block to mass 
storage. a-addr is the address of that block buffer. At the 
conclusion of the operation, the block buffer pointed to by addr 
is the current block buffer and is assigned to n.



BUFFER: CORE EXT

Syntax: <literal><space>BUFFER:<space><name>

Compiler: The previously compiled literal is taken as an argument 
for BUFFER:. The instruction pointer is decremented, actually 
deleting the literal.

Allocate <literal> address units of contiguous data space 
beginning at <name> in the Character Segment. The initial content 
of the allocated space is undefined.



C! CORE

Pronunciation: c-store

Compiles to: C! (0)

Stack effects: c addr ---

Store 8 bits of c at address addr in the Character Segment.



C" 4TH

Syntax: C"<space><string>"

Compiler: All printable characters from the string are added as 
characters to the String Segment. Nothing is actually compiled.

Forth: There is a rarely used[footnote:
A.3.1.3.4 Counted strings (abridged): ”Forth 94 moved toward the 
consistent use of the 'c-addr u' representation of strings on the 
stack. The use of the alternate 'address of counted string' stack 
representation is discouraged. The new word C", added as a 
porting aid for existing programs, also uses the counted string 
representation”. 
] CORE EXT word in ANS-Forth with the same name. This one behaves 
entirely different.

Reserve space for all the printable characters of the string 
issued in the String Segment and store those characters in that 
space.



C, CORE

Pronunciation: c-comma

Syntax: <literal><space>C,

Compiler: The previously compiled literal is added as a character 
to the String Segment. The instruction pointer is decremented, 
actually deleting the literal.

Forth: Forth pops a value from the stack. This is not possible in 
4tH. 

Reserve space for one character in the String Segment and store 
char in the space.



C@ CORE

Pronunciation: c-fetch

Compiles to: C@ (0)

Stack effects: addr --- c

Leave the 8 bits contents of Character Segment address addr as c.



CATCH EXCEPTION

Compiles to: CATCH (0)

  (CATCH) (0)

Stack effects: xt --- n

Push an exception frame on the return stack and execute the 
execution token xt in such a way that control can be transferred 
to a point just after CATCH if THROW is executed during the 
execution of xt (see: THROW).



CELL+ CORE

Pronunciation: cell-plus

Compiles to: +LITERAL (1)

Stack effects: x1 --- x2

Add the the size of a cell in cells to x1 giving x2.



CELL- COMUS

Compiles to: +LITERAL (-1)

Stack effects: x1 --- x2

Subtract the the size of a cell in cells to x1 giving x2.



CELLS CORE

Compiler: The instruction pointer is not incremented. In fact, 
CELLS is a dummy.

Stack effects: n --- n

n is the size in cells of n cells.



CFIELD: FACILITY EXT

Syntax: CFIELD:<space><name>

Compiler: The previously compiled literal is taken as an argument 
for CFIELD: and incremented afterwards. The instruction pointer 
is left unchanged.

Forth: This word may only be used in structures that are 
completely made up out of CHARS. In Forth, there is no such 
restriction.

The semantics are identical to the execution semantics of the 
phrase 1 CHARS +FIELD.





CHAR CORE

Pronunciation: char

Compiles to: LITERAL (<ASCII-value of character>)

Syntax: CHAR<space><char>

Stack effects: --- c

Compiles the ASCII-value of <char> as a literal. At runtime the 
value is thrown on the stack.



CHAR+ CORE

Pronunciation: char-plus

Compiles to: +LITERAL (1)

Stack effects: addr1 --- addr2

Add the the size of a character in characters to addr1 giving 
addr2.



CHAR- 4TH

Compiles to: +LITERAL (-1)

Stack effects: addr1 --- addr2

Subtract the the size of a character in characters to addr1 
giving addr2.



CHARS CORE

Pronunciation: chars

Compiler: The instruction pointer is not incremented. In fact, 
CHARS is a dummy.

Stack effects: n --- n

Forth: In 4tH CHARS is a dummy, but it can be used to make a 
program ANS-compatible.

n is the size in characters of n characters.



CHOP 4TH

Compiles to: +LITERAL (-1)

  SWAP (0)

  +LITERAL (1)

  SWAP (0)

Stack effects: a n --- a+1 n-1

Deletes the first character from the string defined by address a 
and length n.



CIN 4TH

Compiles to: ENVIRON (<address of CIN>)

Stack effects: --- n

Identifies the input source.



CLOSE 4TH

Compiles to: CLOSE (0)

Stack effects: h ---

CLOSE will close a file or pipe, previously opened by OPEN and 
release the stream. Depending on the file access method, the 
terminal will be made the current input-device, otherwise the 
screen will be made the current output-device.



CLOSE-BLOCKFILE SOURCEFORGE

Include: ansblock.4th

  multiblk.4th

Stack effects: ---

Flush and close the current block file.



CLOSE-FILE FILE

Include: ansfile.4th

Stack effects: h --- f

Close the file identified by handle h. Flag f is the 
implementation-defined I/O result code.



CMOVE STRING

Pronunciation: c-move

Compiles to: CMOVE (0)

Stack effects: addr1 addr2 n ---

Forth: In Forth there are two words for this operation, CMOVE and 
CMOVE>. Usage depends on the direction of the move. In 4tH CMOVE 
is smart, like MOVE.

Move the specified quantity of bytes (n) beginning at address 
addr1 to addr2.



CMOVE> STRING

Pronunciation: c-move-up

Compiles to: CMOVE (0)

Stack effects: addr1 addr2 n ---

An alias for CMOVE (see: CMOVE).



COMPARE STRING

Include: compare.4th

Stack effects: addr1 n1 addr2 n2 --- n3

Compare the string specified by addr1 n1 to the string specified 
by addr2 n2 . The strings are compared, beginning at the given 
addresses, character by character, up to the length of the 
shorter string or until a difference is found. If the two strings 
are identical, n3 is zero. If the two strings are identical up to 
the length of the shorter string, n3 is -1 if n1 is less than n2 
and 1 otherwise. If the two strings are not identical up to the 
length of the shorter string, n3 is -1 if the first non-matching 
character in the string specified by addr1 n1 has a lesser 
numeric value than the corresponding character in the string 
specified by addr2 n2 and 1 otherwise.



CONSTANT CORE

Syntax: <literal><space>CONSTANT<space><name>

Compiler: The previously compiled literal is taken as an argument 
for CONSTANT. The instruction pointer is decremented, actually 
deleting the literal.

Forth: In Forth, the literal value is popped from the stack. This 
cannot be done in 4tH.

A defining word used to create word <name>. When <name> is later 
executed, it will push the value of <literal> on the stack.



COUNT CORE

Compiles to: COUNT (0)

Stack effects: addr1 --- addr2 n

Forth: Programs assuming that the string is a so-called counted 
string will not work. Well-written programs only assume the 
correct input- and output-parameters.

Leave the Character Segment address addr2 and count n of an 
ASCIIZ string beginning at Character Segment address addr1. 
Typically COUNT is followed by TYPE.



COUT 4TH

Compiles to: ENVIRON (<address of COUT>)

Stack effects: --- n

Identifies the output source.



CR CORE

Pronunciation: c-r

Compiles to: CR (0)

Transmit a carriage return to the selected output-device. The 
actual sequence sent is OS- and stream-dependant.



CREATE CORE

Syntax: CREATE<space><name>

Forth: In Forth this will create a dictionary header.

Leaves <name> in the symboltable and replace further occurences 
with LITERAL <xt>. <xt> represents the address in the Code 
Segment where CREATE was compiled.



CREATE-BLOCKFILE SOURCEFORGE

Include: ansblock.4th

  multiblk.4th

Stack effects: n1 addr n2---

Create a blank block file named in the character string specified 
by addr and n2, with a size of n1 blocks.



CREATE-FILE FILE

Include: ansfile.4th

Stack effects: addr n fam --- h f

Create the file named in the character string specified by addr 
and n, and open it with file access method fam. The meaning of 
values of fam is implementation defined. If a file with the same 
name already exists, recreate it as an empty file. If the file 
was successfully created and opened, f is zero, handle h is its 
identifier, and the file has been positioned to the start of the 
file. Otherwise, f is the implementation-defined I/O result code 
and h is undefined.





C| 4TH

Syntax: C|<space><string>|

Compiler: All printable characters from the string are added as 
characters to the String Segment. Nothing is actually compiled.

Reserve space for all the printable characters of the string 
issued in the String Segment and store those characters in that 
space.



D+ DOUBLE

Pronunciation: d-plus

Include: ansdbl.4th

Stack effects: d1 d2 --- d3

Add d1 to d2, giving the sum d3.



D- DOUBLE

Pronunciation: d-minus

Include: ansdbl.4th

Stack effects: d1 d2 --- d3

Subtract d2 from d1, giving the difference d3.



D. DOUBLE

Pronunciation: d-dot

Include: dbldot.4th

Stack effects: d --- 

Display d in free field format.



D.R DOUBLE

Pronunciation: d-dot-r

Include: dbldot.4th

Stack effects: d n --- 

Display d right aligned in a field n characters wide. If the 
number of characters required to display d is greater than n, all 
digits are displayed with no leading spaces in a field as wide as 
necessary.



D0< DOUBLE

Pronunciation: d-zero-less

Include: ansdbl.4th

Stack effects: d --- f

Flag f is true if and only if d is less than zero.



D0= DOUBLE

Pronunciation: d-zero-equals

Include: ansdbl.4th

Stack effects: d --- f

Flag f is true if and only if d is equal to zero.



D2* DOUBLE

Pronunciation: d-two-star

Include: ansdbl.4th

Stack effects: d1 --- d2

D2 is the result of shifting d1 one bit toward the 
most-significant bit, filling the vacated least-significant bit 
with zero.



D2/ DOUBLE

Pronunciation: d-two-slash

Include: ansdbl.4th

Stack effects: d1 --- d2

D2 is the result of shifting d1 one bit toward the 
least-significant bit, leaving the most-significant bit 
unchanged.



D< DOUBLE

Pronunciation: d-less-than

Include: ansdbl.4th

Stack effects: d1 d2 --- f

Flag f is true if and only if d1 is less than d2.



D= DOUBLE

Pronunciation: d-equals

Include: ansdbl.4th

Stack effects: d1 d2 --- f

Flag f is true if and only if d1 is equal to d2.



D>F FLOATING

Pronunciation: d-to-f

Include: ansfloat.4th

  zentodbl.4th

Stack effects: d ---

Floating: --- r

r is the floating-point equivalent of d. An ambiguous condition 
exists if d cannot be precisely represented as a floating-point 
value.



D>S DOUBLE

Pronunciation: d-to-s

Compiler: The instruction pointer is not incremented. In fact, 
D>S is a dummy.

Stack effects: n --- n

Convert the number n to number n with the same numerical value.



DABS DOUBLE

Pronunciation: d-abs

Include: ansdbl.4th

Stack effects: d1 --- d2

D2 is the absolute value of d1.



DECIMAL CORE

Compiles to: RADIX (10)

Forth: See HEX.

Set the numeric conversion BASE for decimal output at runtime.



DEFER CORE EXT

Compiles to: LITERAL ((ERROR))

  TO (<variable address>)

Syntax: DEFER<space><name>

Stack effects: ---

Create a value name which will hold an execution token for a word 
whose behavior will be determined later and may be varied. The 
initial value will trigger an error if used before proper 
assignment.



DEFER! CORE EXT

Compiles to: ENVIRON (<address of FIRST>)

  + (0)

  ! (0)

Stack effects: xt x ---

Set the vector x to execute xt.



DEFER@ CORE EXT

Compiles to: ENVIRON (<address of FIRST>)

  + (0)

  @ (0)

Stack effects: x --- xt

xt is the xt associated with the deferred word corresponding to 
x.



DELETE-FILE FILE

Compiles to: DELETE-FILE (0)

Stack effects: a n --- f

Delete the ﬁle named in the character string speciﬁed by c-addr 
u. Return zero on success or true on failure.



DEPTH CORE

Compiles to: SP@ (0)

Stack effects: --- n

Returns the number of items on the stack in n, before DEPTH was 
executed. An alias for SP@.



DMAX DOUBLE

Pronunciation: d-max

Include: ansdbl.4th

Stack effects: d1 d2 --- d3

D3 is the greater of d1 and d2.



DMIN DOUBLE

Pronunciation: d-min

Include: ansdbl.4th

Stack effects: d1 d2 --- d3

D3 is the lesser of d1 and d2.



DNEGATE DOUBLE

Pronunciation: d-negate

Include: ansdbl.4th

Stack effects: d1 --- d2

D2 is the negation of d1.



DO CORE

Compiles to: DO (0)

Syntax: DO<space>..<space>+LOOP

  DO<space>..<space>LOOP

Stack effects: n1 n2 ---

At runtime DO begins a sequence with repetitive execution 
controlled by a loop limit n1 and an index with initial value n2. 
DO removes these from the stack. Upon reaching LOOP or +LOOP the 
index is altered. Until the new index equals or exceeds the 
limit, execution loops back to just after DO; otherwise the loop 
parameters are discarded and execution continues ahead. Both n1 
and n2 are determined at runtime and may be the result of other 
operations. Within a loop I will copy the current value of the 
index on the stack.



DOES> CORE

Pronunciation: does

Compiles to: BRANCH (<address of matching ; token>)

  LITERAL (<original value>) | VARIABLE (<original value>)

Syntax: CREATE|BUFFER:|STRING|CONSTANT|VARIABLE|ARRAY<space>..
<space>DOES><space>..<space>;

Forth: In ANS-Forth, DOES> is typically combined with CREATE and 
has no interpretation semantics. The typical use of DOES> in 4tH 
will lead usually to compilation errors. Some Forth compilers 
(like gForth) are largely compatible with this 4tH construct.

Replace the execution semantics of the most recent definition 
with the execution semantics following DOES>. An error condition 
exists if the most recent definition was not a CREATE, BUFFER:, 
STRING, CONSTANT, VARIABLE or ARRAY.





DONE 4TH

Compiles to: BRANCH (<address of matching DONE, REPEAT or UNTIL 
token>)

Syntax: WHILE<space>..<space>DONE<space>..<space>DONE

Forth: Equivalent to:

  : DONE 1 CS-ROLL POSTPONE ELSE 1 CS-ROLL ; IMMEDIATE

At runtime DONE executes after the true following WHILE. DONE 
forces execution to skip over the following false part and 
resumes execution after the second DONE, which skips execution to 
just after REPEAT or UNTIL, effectively exiting the structure. 



DROP CORE

Compiles to: DROP (0)

Stack effects: n ---

Drop the number from the stack.



DU< DOUBLE EXT

Pronunciation: d-u-less

Include: ansdbl.4th

Stack effects: d1 d2 --- f

Flag is true if and only if usigned double d1 is less than 
unsigned double d2.



DUMP TOOLS

Include: dump.4th

  dumpbase.4th

Stack effects: addr n --- 

Display the contents of n consecutive addresses starting at addr.



DUP CORE

Pronunciation: dupe

Compiles to: DUP (0)

Stack effects: n --- n n

Duplicate the value on the stack.



ELSE CORE

Compiles to: BRANCH (<address of matching THEN token>)

Syntax: IF<space>..<space>ELSE<space>..<space>THEN

At runtime ELSE executes after the true following IF. ELSE forces 
execution to skip over the following false part and resumes 
execution after the THEN.



EMIT CORE

Compiles to: EMIT (0)

Stack effects: c ---

Transmit the ASCII character with code n to the selected output 
device.



EMPTY-BUFFERS BLOCK EXT

Include: ansblock.4th

  multiblk.4th

Stack effects: ---

Unassign all block buffers. Do not transfer the contents of any 
UPDATEd block buffer to mass storage.



END-STRUCT 4TH

Syntax: 
STRUCT<space><literal><space>+FIELD<space><name><space>END-STRUCT<space><name>

  
STRUCT<space><literal><space>/FIELD<space>END-STRUCT<space><name>

Compiler: The previously compiled literal is taken as an argument 
for END-STRUCT, creating a constant that holds the length of the 
STRUCT. The instruction pointer is decremented, actually deleting 
the literal.

Forth: Similar constructions are available in gForth. +FIELD is 
part of the Forth 200x draft.

Terminate the definition of a STRUCT. The created structure is an 
constant that memorizes the size of the structure (see: +FIELD, 
/FIELD, STRUCT). 



ENUM 4TH

Syntax: <literal><space>ENUM<space><name>

Compiler: The previously compiled literal is taken as an argument 
for ENUM and incremented afterwards. The instruction pointer is 
left unchanged.

Forth: This word is available in some Forths.

A defining word used to create word <name>. When <name> is later 
executed, it will push the value of <literal> on the stack.



ENVIRON@ 4TH

Compiles to: ENVIRON@ (0)

Stack effects: addr1 n1 --- addr2 n2

addr1 is the address of a character string containing the name of 
an environment variable and n1 is the string's character count. 
If successful, it returns address addr2 and count n2 of the 
contents of the environment variable. On error both address addr2 
and count n2 are zero. Note that the contents may be truncated if 
there is not enough space available in the PAD. 



ENVIRONMENT? CORE

Pronunciation: environment-query

Include: environ.4th

Stack effects: addr n --- -f

addr is the address of a character string and n is the string's 
character count. The character string should contain a keyword 
from ANS-Forth environmental queries or the optional word sets to 
be checked for correspondence with an attribute of the present 
environment. The system treats the attribute as unknown, the 
returned flag is false.



EQUATES 4TH

Syntax: <variable><space>EQUATES<space><name>

Compiler: A variable, with an optional literal expression 
containing an offset, is entered as a new variable in the symbol 
table.

Forth: This word is equivalent to CONSTANT in most Forths.

A defining word used to create a static pointer to a variable or 
an array, which will behave as if it were a normal variable. When 
<name> is later executed, it will push the address <var> on the 
stack, so that a fetch or store may access this location.



ERASE CORE EXT

Compiles to: LITERAL (0)

  FILL (0)

Stack effects: addr n ---

If n is greater than zero, clear all bits in each of n 
consecutive address units of memory beginning at addr.



ERROR? 4TH

Compiles to: LITERAL (<largest negative integer>)

  OVER (0)

  = (0)

Stack effects: n --- n f

If n equals (ERROR), leave a true flag, otherwise leave a false 
flag. Determines whether n indicates an error condition. The 
resulting stack diagram is ANS-Forth compliant. 



EVALUATE CORE

Include: evaluate.4th

Stack effects: addr n ---

Forth: In Forth, the entire dictionary is available. In 4tH, the 
only words available are explicitly defined by the program.

Make the string described by addr and n the input buffer and 
interpret. Other stack effects are due to the words EVALUATEd.



EXECUTE CORE

Compiles to: EXECUTE (0)

Stack effects: xt ---

Execute the colon definition whose token-address xt is on the 
stack. The current token-address is pushed on the returnstack.



EXIT CORE

Compiles to: EXIT (0)

When compiled within a colon-definition, terminates execution of 
that definition at that point. At runtime functionally equivalent 
to ;.



EXPECT CORE EXT

Include: obsolete.4th

Stack effects: addr n --- 

Receive a string of at most n-1 characters. The editing 
functions, if any, that the system performs in order to construct 
the string of characters are implementation-defined. Input 
terminates when an implementation-defined line terminator is 
received or when the string is n-1 characters long. When input 
terminates the display is maintained in an implementation-defined 
way. Store the string at addr and its length in SPAN (see SPAN).



F! FLOATING

Pronunciation: f-store

Include: ansfloat.4th

  zenans.4th

Stack effects: x ---

Floating: r ---

Store r at address x.



F* FLOATING

Pronunciation: f-star

Include: ansfloat.4th

  zenfloat.4th

Stack effects: ---

Floating: r1 r2 --- r3

Multiply r1 by r2 giving r3.



F** FLOATING EXT

Pronunciation: f-star-star

Include: falog.4th

  zenfalog.4th

Stack effects: ---

Floating: r1 r2 --- r3

Raise r1 to the power r2, giving the product r3.



F+ FLOATING

Pronunciation: f-plus

Include: ansfloat.4th

  zenfloat.4th

Stack effects: ---

Floating: r1 r2 --- r3

Add r1 to r2 giving the sum r3.



F- FLOATING

Pronunciation: f-minus

Include: ansfloat.4th

  zenfloat.4th

Stack effects: ---

Floating: r1 r2 --- r3

Subtract r2 from r1 giving r3.



F. FLOATING EXT

Pronunciation: f-dot

Include: ansfpio.4th

  zenfpio.4th

  fpout.4th

Stack effects: ---

Floating: r ---

Display, with a trailing space, the top number on the 
floating-point stack using fixedpoint notation. An ambiguous 
condition exists if the value of BASE is not (decimal) ten or if 
the character string representation exceeds the size of the 
pictured numeric output string buffer.



F/ FLOATING

Pronunciation: f-slash

Include: ansfloat.4th

  zenfloat.4th

Stack effects: ---

Floating: r1 r2 --- r3

Divide r1 by r2, giving the quotient r3. An ambiguous condition 
exists if r2 is zero, or the quotient lies outside of the range 
of a floating-point number.



F0< FLOATING

Pronunciation: f-zero-less-than

Include: ansfloat.4th

  zenfloat.4th

Stack effects: --- f

Floating: r ---

Flag f is true if and only if r is less than zero.



F0= FLOATING

Pronunciation: f-zero-equals

Include: ansfloat.4th

  zenfloat.4th

Stack effects: --- f

Floating: r ---

Flag f is true if and only if r is equal to zero.





F< FLOATING

Pronunciation: f-less-than

Include: ansfloat.4th

  zenfloat.4th

Stack effects: --- f

Floating: r1 r2 ---

Flag f is true if and only if r1 is less than r2.



F>D FLOATING

Pronunciation: f-to-d

Include: ansfloat.4th

  zentodbl.4th

Stack effects: --- d

Floating: r ---

Double number d is the double-cell signed-integer equivalent of 
the integer portion of r. The fractional portion of r is 
discarded. An ambiguous condition exists if the integer portion 
of r cannot be precisely represented as a double-cell signed 
integer.



F>S FLOATING EXT

Pronunciation: f-to-s

Include: ansfloat.4th

  zenfloat.4th

Stack effects: --- n

Floating: r ---

Number n is the less significant portion of the double word that 
would be produced by the word F>D applied to the floating-point 
value r. An ambiguous condition exists if applying F>D to r would 
result in an ambiguous condition.



F@ FLOATING

Pronunciation: f-fetch

Include: ansfloat.4th

  zenans.4th

Stack effects: x ---

Floating: --- r

Float r is the value stored at address x.



FABS FLOATING EXT

Pronunciation: f-abs

Include: ansfloat.4th

  zenfloat.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the absolute value of r1.



FACOS FLOATING EXT

Pronunciation: f-a-cos

Include: asinacos.4th

  zenfasin.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the principal radian angle whose cosine is r1. An 
ambiguous condition exists if | r1 | is greater than one.



FACOSH FLOATING EXT

Pronunciation: f-a-cosh

Include: fatanh.4th

  zenatanh.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the floating-point value whose hyperbolic cosine is 
r1. An ambiguous condition exists if r1 is less than one.



FALIGN FLOATING

Pronunciation: f-align

Include: ansfloat.4th

Stack effects: ---

Floating: ---

If the data-space pointer is not float aligned, reserve enough 
data space to make it so. In 4tH, it is a dummy.



FALIGNED FLOATING

Pronunciation: f-aligned

Include: ansfloat.4th

Stack effects: x --- x

Floating: ---

Address x is the first float-aligned address greater than or 
equal to address x. In 4tH, it is a dummy.



FALOG FLOATING EXT

Pronunciation: f-a-log

Include: falog.4th

  zenfalog.4th

Stack effects: ---

Floating: r1 --- r2

Raise ten to the power r1, giving r2.



FALSE CORE EXT

Compiles to: LITERAL (<false>)

Stack effects: --- -f

Returns a FALSE flag on the stack.



FASIN FLOATING EXT

Pronunciation: f-a-sine

Include: asinacos.4th

  zenfasin.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the principal radian angle whose sine is r1. An 
ambiguous condition exists if | r1 | is greater than one.



FASINH FLOATING EXT

Pronunciation: f-a-cinch

Include: fatanh.4th

  zenatanh.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the floating-point value whose hyperbolic sine is r1. 
An ambiguous condition exists if r1 is less than zero.



FATAN FLOATING EXT

Pronunciation: f-a-tan

Include: asinacos.4th

  zenfasin.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the principal radian angle whose tangent is r1.



FATAN2 FLOATING EXT

Pronunciation: f-a-tan-two

Include: fatan2.4th

  zenatan2.4th

Stack effects: ---

Floating: r1 r2 --- r3

Float r3 is the radian angle whose tangent is r1/r2. An ambiguous 
condition exists if r1 and r2 are zero.



FATANH FLOATING EXT

Pronunciation: f-a-tan-h

Include: fatanh.4th

  zenatanh.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the floating-point value whose hyperbolic tangent is 
r1. An ambiguous condition exists if r1 is outside the range of 
-1 to 1.



FCOS FLOATING EXT

Pronunciation: f-cos

Include: fsinfcos.4th

  fsincost.4th

  zenfsin.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the cosine of the radian angle r1.



FCOSH FLOATING EXT

Pronunciation: f-cosh

Include: sinhcosh.4th

  zenfsinh.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the hyperbolic cosine of r1.



FDEPTH FLOATING

Pronunciation: f-depth

Include: ansfloat.4th

Stack effects: --- n

Floating: ---

N is the number of values contained on the default separate 
floating-point stack.



FDROP FLOATING

Pronunciation: f-drop

Include: ansfloat.4th

  zenans.4th

Stack effects: ---

Floating: r ---

Remove r from the floating-point stack.



FDUP FLOATING

Pronunciation: f-dupe

Include: ansfloat.4th

  zenans.4th

Stack effects: ---

Floating: r --- r r

Duplicate r.



FE. FLOATING EXT

Pronunciation: f-e-dot

Include: ansfpio.4th

  fpout.4th

Stack effects: ---

Floating: r ---

Display, with a trailing space, the top number on the 
floating-point stack using engineering notation, where the 
significand is greater than or equal to 1.0 and less than 1000.0 
and the decimal exponent is a multiple of three. An ambiguous 
condition exists if the value of BASE is not (decimal) ten or if 
the character string representation exceeds the size of the 
pictured numeric output string buffer.



FEXP FLOATING EXT

Pronunciation: f-e-x-p

Include: fexp.4th

  fexpt.4th

  zenfexp.4th

Stack effects: ---

Floating: r1 --- r2

Raise e to the power r1, giving r2.



FEXPM1 FLOATING EXT

Pronunciation: f-e-x-p-m-one

Include: fexpm1.4th

  zenexpm1.4th

Stack effects: ---

Floating: r1 --- r2

Raise e to the power r1 and subtract one, giving r2.



FIELD: FACILITY EXT

Syntax: FIELD:<space><name>

Compiler: The previously compiled literal is taken as an argument 
for FIELD: and incremented afterwards. The instruction pointer is 
left unchanged.

Forth: This word may only be used in structures that are 
completely made up out of CELLS. In Forth, there is no such 
restriction.

The semantics are identical to the execution semantics of the 
phrase ALIGNED 1 CELLS +FIELD.





FILE 4TH

Compiles to: LITERAL ((ERROR))

  TO (<variable address>)

Syntax: FILE<space><name>

Stack effects: ---

Create a value name which will hold a filehandle. The initial 
value will trigger an error if used before proper assignment.



FILE-POSITION FILE

Include: ansfile.4th

Stack effects: h --- n f

n is the current file position for the file identified by handle 
h. Flag f is the implementation-defined I/O result code. n is 
undefined if f is non-zero.



FILE-SIZE FILE

Include: ansfile.4th

Stack effects: h --- n f

n is the size, in characters, of the file identified by handle h. 
Flag f is the implementation-defined I/O result code. This 
operation does not affect the value returned by FILE-POSITION. n 
is undefined if f is true.



FILE-STATUS FILE EXT

Include: ansfile.4th

Stack effects: addr n1 --- n2 f

Return the status of the file identified by the character string 
addr n1. If the file exists, flag f is zero; otherwise flag f is 
the implementation-defined I/O result code. n2 contains 
implementation defined information about the file.



FILES 4TH

Compiles to: LITERAL (<number of open files>)

Stack_effects: --- n

Returns the maximum number of open streams 4tH can handle. Two of 
these streams are predefined, STDIN and STDOUT.



FILL CORE

Compiles to: FILL (0)

Stack effects: addr n c ---

Fills n bytes in the Character Segment, beginning at address 
addr, with character c.



FIRST 4TH

Compiles to: ENVIRON (<address of FIRST>)

Stack effects: --- x

Leaves the variable address x of the first user-variable. If 
FIRST is greater than LAST, no user-variables have been defined.



FLN FLOATING EXT

Pronunciation: f-l-n

Include: flnflog.4th

  flnflogb.4th

  zenfln.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the natural logarithm of r1. An ambiguous condition 
exists if r1 is less than or equal to zero.



FLNP1 FLOATING EXT

Pronunciation: f-l-n-p-one

Include: flnp1.4th

  zenflnp1.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the natural logarithm of the quantity r1 plus one. An 
ambiguous condition exists if r1 is less than or equal to 
negative one.





FLOAT+ FLOATING

Pronunciation: float-plus

Include: ansfloat.4th

  zenans.4th

Stack effects: x1 --- x2

Floating: ---

Add the size in address units of a floating-point number to 
address x1, giving address x2.



FLOATS FLOATING

Include: ansfloat.4th

  zenans.4th

Stack effects: n1 --- n2

Floating: ---

Number n2 is the size in address units of n1 floating-point 
numbers.



FLOG FLOATING EXT

Pronunciation: f-log

Include: flnflog.4th

  flnflogb.4th

  zenfln.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the base-ten logarithm of r1. An ambiguous condition 
exists if r1 is less than or equal to zero.



FLOOR FLOATING

Include: ansfloat.4th

  zenfloor.4th

Stack effects: ---

Floating: r1 --- r2

Round r1 to an integral value using the ”round toward negative 
infinity” rule, giving r2.



FLUSH BLOCK

Include: ansblock.4th

  multiblk.4th

Stack effects: ---

Perform the function of SAVE-BUFFERS, then unassign the block 
buffer.



FLUSH-FILE FILE EXT

Include: ansfile.4th

Stack effects: h --- f

Attempt to force any buffered information written to the file 
referred to by handle h to be written to mass storage, and the 
size information for the file to be recorded in the storage 
directory if changed. If the operation is successful, f is zero. 
Otherwise, it is an implementation-defined I/O result code. 



FM/MOD CORE

Pronunciation: f-m-slash-mod

Include: mixed.4th

Stack effects: d1 n1 --- n2 n3

Divide d1 by n1, giving the floored quotient n3 and the remainder 
n2. Input and output stack arguments are signed. An ambiguous 
condition exists if n1 is zero or if the quotient lies outside 
the range of a single-cell signed integer.



FMAX FLOATING

Pronunciation: f-max

Include: ansfloat.4th

  zenfmin.4th

Stack effects: ---

Floating: r1 r2 --- r3

Float r3 is the greater of r1 and r2.



FMIN FLOATING

Pronunciation: f-min

Include: ansfloat.4th

  zenfmin.4th

Stack effects: ---

Floating: r1 r2 --- r3

Float r3 is the lesser of r1 and r2.



FNEGATE FLOATING

Pronunciation: f-negate

Include: ansfloat.4th

  zenfloat.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the negation of r1.



FOVER FLOATING

Pronunciation: f-over

Include: ansfloat.4th

  zenans.4th

Stack effects: ---

Floating: r1 r2 --- r1 r2 r1

Place a copy of r1 on top of the floating-point stack.



FREE MEMORY

Include: ansmem.4th

  memchar.4th

  memcell.4th

Stack effects: addr --- f

Return the contiguous region of data space indicated by addr to 
the system for later allocation. addr shall indicate a region of 
data space that was previously obtained by ALLOCATE or RESIZE. If 
the operation succeeds, f is false. If the operation fails, f is 
true.



FROT FLOATING

Pronunciation: f-rot

Include: ansfloat.4th

  zenans.4th

Stack effects: ---

Floating: r1 r2 r3 --- r2 r3 r1

Rotate the top three floating-point stack entries.



FROUND FLOATING

Pronunciation: f-round

Include: ansfloat.4th

  zenround.4th

Stack effects: ---

Floating: r1 --- r2

Round r1 to an integral value using the ”round to nearest” rule, 
giving r2.



FS. FLOATING EXT

Pronunciation: f-s-dot

Include: ansfpio.4th

  fpout.4th

Stack effects: ---

Floating: r ---

Display, with a trailing space, the top number on the 
floating-point stack in scientific notation. An ambiguous 
condition exists if the value of BASE is not (decimal) ten or if 
the character string representation exceeds the size of the 
pictured numeric output string buffer.



FSIN FLOATING EXT

Pronunciation: f-sine

Include: fsinfcos.4th

  fsincost.4th

  zenfsin.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the sine of the radian angle r1.



FSINCOS FLOATING EXT

Pronunciation: f-sine-cos

Include: fsinfcos.4th

  fsincost.4th

  zenfsin.4th

Stack effects: ---

Floating: r1 --- r2 r3

Float r2 is the sine of the radian angle r1. Float r3 is the 
cosine of the radian angle r1. 



FSINH FLOATING EXT

Pronunciation: f-cinch

Include: sinhcosh.4th

  zenfsinh.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the hyperbolic sine of r1.



FSQRT FLOATING EXT

Pronunciation: f-square-root

Include: ansfloat.4th

  zenfsqrt.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the square root of r1. An ambiguous condition exists 
if r1 is less than zero.



FSWAP FLOATING

Pronunciation: f-swap

Include: ansfloat.4th

  zenans.4th

Stack effects: ---

Floating: r1 r2 --- r2 r1

Exchange the top two floating-point stack items.



FTAN FLOATING EXT

Pronunciation: f-tan

Include: fsinfcos.4th

  fsincost.4th

  zenfsin.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the tangent of the radian angle r1. An ambiguous 
condition exists if cos (r1) is zero.



FTANH FLOATING EXT

Pronunciation: f-tan-h

Include: sinhcosh.4th

  zenfsinh.4th

Stack effects: ---

Floating: r1 --- r2

Float r2 is the hyperbolic tangent of r1.



F~ FLOATING EXT

Pronunciation: f-proximate

Include: ansfloat.4th

  zenfprox.4th

Stack effects: --- f

Floating: r1 r2 r3 ---

If r3 is positive, flag is true if the absolute value of (r1 
minus r2) is less than r3. If r3 is zero, flag is true if the 
implementation-dependent encoding of r1 and r2 are exactly 
identical. If r3 is negative, flag is true if the absolute value 
of (r1 minus r2) is less than the absolute value of r3 times the 
sum of the absolute values of r1 and r2.



HERE CORE

Compiles to: LITERAL (<token address>)

Stack effects: --- xt

Forth: Leaves the address of the next available dictionary 
location. Since 4tH doesn't have a dictionary location, its use 
is very different.

At runtime, HERE leaves the address xt in the Code Segment where 
it was compiled.



HEX CORE EXT

Compiles to: RADIX (16)

Forth: In Forth this construction

  HEX : SOMETIN 16 ;

  will compile 16 as a hexadecimal number. In 4tH it will simply 
be compiled and 16 will be compiled as a decimal number. To 
emulate this construction use

  [HEX] : SOMETIN 16 ;

  instead.

Set the numeric conversion BASE for hexadecimal output at 
runtime.



HI 4TH

Compiles to: ENVIRON (<address of HI>)

Stack effects: --- addr

Leaves the address of the last character in the Character 
Segment.



HIDE 4TH

Syntax: HIDE<space><name>

Find <name>, then delete name from the symbol table. Used to 
create private definitions.



HOLD CORE

Compiles to: HOLD (0)

Stack effects: c ---

Used between <# and #> to insert an ASCII character into a 
pictured numeric output string, e.g. [HEX] 2E HOLD will place a 
decimal point.



HOLDS CORE EXT

Include: holds.4th

Stack effects: a n ---

Adds a string to the picture numeric output buffer.



I CORE

Compiles to: I (0)

Stack effects: --- n

Used with a DO .. LOOP to copy the loop index to the stack. An 
alias for R.



IF CORE

Compiles to: 0BRANCH (<address of matching ELSE|THEN token>)

Stack effects: f ---

Syntax: See ELSE, THEN

At runtime, IF selects execution based on f. If f is non-zero, 
execution continues ahead through the true part. If f is zero 
execution skips till just after ELSE to execute the false part. 
After each part, execution resumes after THEN.



IMMEDIATE CORE

Compiler: The instruction pointer is not incremented. In fact, 
IMMEDIATE is a dummy.

Stack effects: ---

Make the most recent definition an immediate word.



INCLUDE COMUS

Syntax: INCLUDE<space><string><space>

Compiler: The contents of the file are inserted at this position.

An alias for [NEEDS (see: [NEEDS).



INPUT 4TH

Compiles to: LITERAL (<fam>)

Stack effects: --- fam

This will leave a file access method on the stack, signalling an 
operation on an input-device.



INVERT CORE

Compiles to: INVERT (0)

Stack effects: n1 --- n2

Leave n1's binary complement as n2. This word is not equivalent 
to 0=.



IS CORE EXT

Compiles to: TO (<variable address>)

Stack effects: xt ---

Syntax: IS<space><name>

Store xt in the value identified by name, previously defined by 
DEFER (see: DEFER).



J CORE

Compiles to: J (0)

Stack effects: --- n

Used with an embedded DO .. +LOOP to copy the outer loop index to 
the stack. Copies in fact the third item of the returnstack.



KEY CORE

Include: key.4th

Stack effects: --- c

Forth: This implementation is identical to the one in pForth. It 
requires hitting the <ENTER> key, before any character is 
returned.

Receive one character char, a member of the 
implementation-defined character set. All standard characters can 
be received. 





KEY? FACILITY

Pronunciation: key-question

Include: key.4th

Stack effects: --- f

Forth: This implementation is identical to the one in pForth. 
KEY? always returns false.

If a character is available, return true. Otherwise, return 
false. 





LAST 4TH

Compiles to: ENVIRON (<address of LAST>)

Stack effects: --- x

Leaves the variable address x of the last variable in the 
Variable Area.



LATEST 4TH

Compiles to: The last defined word

Compile the last word that has been added to the symbol table 
(defined). Is equivalent to RECURSE if used within a colon 
definition. 



LEAVE CORE

Compiles to: LEAVE (0)

Force termination of a DO .. +LOOP at the next opportunity by 
setting the loop index equal to the loop limit. The limit itself 
remains unchanged, and execution proceeds normally until +LOOP is 
encountered.



LIST BLOCK EXT

Include: ansblock.4th

  multiblk.4th

Stack effects: n ---

Display block n in an implementation-defined format. Store n in 
SCR.



LO 4TH

Compiles to: LITERAL (<TIB+PAD>)

Stack effects: --- addr

Leaves the offset of the first character of the Allocation Area 
in the Character Segment. If LO is greater than HI, no memory has 
been allocated.



LOAD BLOCK

Include: ansblock.4th

  multiblk.4th

Before: evaluate.4th

Stack effects: n ---

Forth: In Forth, the entire dictionary is available. In 4tH, the 
only words available are explicitly defined by the program.

Save the current input-source specification. Store n in BLK (thus 
making block n the input source and setting the input buffer to 
encompass its contents), set >IN to zero, and execute EVALUATE. 
When the parse area is exhausted, restore the prior input source 
specification.



LOOP CORE

Compiles to: LOOP (<address of matching DO token>)

Syntax: DO<space>..<space>+LOOP

Used in the form DO .. LOOP. At runtime, LOOP selectively 
controls branching back to the corresponding DO based on the loop 
index and the loop limit. The index is incrementex and compared 
to the limit. The branch back to DO occurs until the new index is 
equal to the limit. Upon exiting the loop, the parameters are 
discarded and execution continues ahead.



LSHIFT CORE

Pronunciation: l-shift

Compiles to: SHIFT (0)

Stack effects: n1 n2 --- n3

Performs a logical bit shift on n1. Specifically, SHIFT shifts a 
number a number of bits, specified in n2, using a logical 
register shift. An alias for SHIFT.



M* CORE

Pronunciation: m-star

Include: mixed.4th

Stack effects: n1 n2 --- d

d is the signed product of n1 times n2.



M*/ DOUBLE

Pronunciation: m-star

Include: mixed.4th

Stack effects: d1 n1 n2 --- d2

Multiply d1 by n1 producing the triple-cell intermediate result 
t. Divide t by n2 giving the double-cell quotient d2. An 
ambiguous condition exists if n2 is zero or negative, or the 
quotient lies outside of the range of a double-precision signed 
integer. 



M+ DOUBLE

Pronunciation: m-star

Include: mixed.4th

Stack effects: d1 n1 --- d2

Add n1 to d1, giving the sum d2. 



MAX CORE

Compiles to: MAX (0)

Stack effects: n1 n2 --- n3

Leave n3 as the greater of the two numbers n1 and n2.



MAX-N COMUS

Compiles to: LITERAL (<largest positive integer>)

Stack effects: --- n

Forth: Equivalent to:

  : MAX-N S" MAX-N" ENVIRONMENT? DROP ;

Returns the largest positive integer that 4tH can handle. Usually 
2^31.



MIN CORE

Compiles to: MIN (0)

Stack effects: n1 n2 --- n3

Leave n3 as the smaller of the two numbers n1 and n2.



MOD CORE

Compiles to: MOD (0)

Stack effects: n1 n2 --- n3

Leave the remainder of n1/n2 with the same sign as n1 in n3.



MOVE CORE

Compiles to: CMOVE (0)

Stack effects: addr1 addr2 n ---

Move the specified quantity of bytes (n) beginning at address 
addr1 to addr2 in the Character Segment.



MS FACILITY EXT

Include: ansfacil.4th

Stack effects: n ---

Forth: In Forth, the resolution is significantly higher than 
between +0 and +1999 ms.

Wait at least u milliseconds.



N>R TOOLS EXT

Include: ntor.4th

Stack effects: n1 n2 n3 nx x --- 

Remove x+1 items from the data stack and store them for later 
retrieval by NR>. The return stack may be used to store the data. 
Until this data has been retrieved by NR>: (a) this data will not 
be overwritten by a subsequent invocation of N>R and (b) a 
program may not access data placed on the return stack before the 
invocation of N>R. Be sure to undercut tail optimization by 
applying the [FORCE] directive to each definition using this 
word! (see [FORCE]).



NEGATE CORE

Compiles to: NEGATE (0)

Stack effects: n1 --- -n1

Leave n1 negated (two's complement).



NIP CORE EXT

Compiles to: SWAP (0)

  DROP (0)

Stack effects: n1 n2 --- n2

Drop the first item below the top of stack.



NOT COMUS

Compiles to: 0= (0)

Stack effects: n --- f

An alias for 0= (see: 0=).



NR> TOOLS EXT

Include: ntor.4th

Stack effects: --- n1 n2 n3 nx x 

Retrieve the items previously stored by an invocation of N>R. x 
is the number of items placed on the data stack. It is an 
ambiguous condition if NR> is used with data not stored by N>R. 
Be sure to undercut tail optimization by applying the [FORCE] 
directive to each definition using this word! (see [FORCE]).



NUMBER 4TH

Compiles to: NUMBER (0)

Stack effects: addr n1 --- n2

Forth: Some Forths support this word too, but issue a message on 
error.

Convert an string at offset addr with length n1 in the Character 
Segment to number n2. If numeric conversion is not possible 
(ERROR) is left on the stack.



OCTAL 4TH

Compiles to: RADIX (8)

Forth: See HEX.

Set the numeric conversion BASE for octal output at runtime.



OFFSET 4TH

Syntax: OFFSET<space><name>

Forth: Equivalent to:

  : OFFSET CREATE DOES> SWAP CHARS + C@ ;

Leaves <name> in the symboltable and replaces further occurences 
of <name> with an execution procedure which takes an index from 
the stack and leaves the character concerned on the stack.



OMIT 4TH

Compiles to: OMIT (0)

Stack effects: c ---

Skips all leading delimiters in the Character Segment, using 
character c as a delimiter.



OPEN 4TH

Compiles to: OPEN (0)

Stack effects: addr n fam --- h

OPEN will open the file, which name has been specified by an 
ASCIIZ string, starting at offset addr in the Character Segment 
and having length n. Depending on the file access method, the 
file or pipe will be opened for reading, otherwise for writing. 
If the file or pipe was succesfully opened it will be connected 
to a stream and a valid filehandle will be left on the stack. If 
not, (ERROR) will be left on the stack. Note that OPEN does not 
connect a stream to a channel (see: USE).



OPEN-BLOCKFILE SOURCEFORGE

Include: ansblock.4th

  multiblk.4th

Stack effects: addr n ---

Open the block file named in the character string specified by 
addr n. If successful then set it as the current block file, 
otherwise abort. 



OPEN-FILE FILE

Include: ansfile.4th

Stack effects: addr n fam --- h f

Open the file named in the character string specified by addr n, 
with file access method indicated by fam. The meaning of values 
of fam is implementation defined. If the file is successfully 
opened, flag f is zero, handle h is its identifier, and the file 
has been positioned to the start of the file. Otherwise, f is the 
implementation-defined I/O result code and h is undefined.



OR CORE

Compiles to: OR (0)

Stack effects: n1 n2 --- n3

Leave the bitwise logical OR in n3 of the numbers n1 and n2.



OUT COMUS

Compiles to: LITERAL (<address of OUT>)

Stack effects: --- x

A variable containing the the value that will be returned to the 
host program.



OUTPUT 4TH

Compiles to: LITERAL (<fam>)

Stack effects: --- fam

This will leave a file access method on the stack, signalling an 
operation on an output-device. 



OVER CORE

Compiles to: OVER (0)

Stack effects: n1 n2 --- n1 n2 n1

Copy the second stack value to the top of the stack.



PAD CORE EXT

Compiles to: LITERAL (<address of PAD>)

Stack effects: --- addr

Leave the address of the text output buffer.



PARSE CORE EXT

Compiles to: PARSE (0)

Stack effects: c --- addr n

Reads a string from the Character Segment, using character c as a 
delimiter. Leaves the addr/count pair addr n. The resulting 
string is not zero-terminated. If the parse area was empty, the 
resulting string has a zero length.



PARSE-WORD 4TH

Compiles to: DUP (0)

  OMIT (0)

  PARSE (0)

Stack effects: c --- addr n

Reads a string from the Character Segment, using character c as a 
delimiter and skipping all leading delimiters. Leaves the 
addr/count pair addr n. The resulting string is not 
zero-terminated.



PAUSE 4TH

Compiles to: PAUSE (0)

Stack_effects: ---

Saves a stackframe, closes all files and quits execution. Leaves 
the virtual machine in a state where it can resume execution.



PICK CORE EXT

Include: pickroll.4th

Stack effects: nu .. n1 n2 u --- nu .. n1 n2 nu

Remove u. Copy the nu to the top of the stack.



PIPE 4TH

Compiles to: LITERAL (<fam>)

Stack effects: --- fam

This will leave a file access method modifier on the stack, 
signalling an operation on a pipe. Must be added to another file 
access modifier. Used in combination with INPUT and OUTPUT. If an 
OS does not support pipes, opening a pipe will always fail.



PLACE COMUS

Compiles to: PLACE (0)

Stack effects: addr1 n addr2 ---

Copies the string at address addr1 with count n to address addr2.



PRECISION FLOATING EXT

Include: ansfloat.4th

  zenans.4th

Stack effects: --- n

Floating: ---

Return the number of significant digits currently used by F, FE, 
or FS as n.



QUERY CORE EXT

Include: obsolete.4th

Stack effects: ---

Make the user input device the input source. Receive input into 
the terminal input buffer, replacing any previous contents. Make 
the result, whose address is returned by TIB, the input buffer. 
Set >IN to zero.



QUIT CORE

Compiles to: QUIT (0)

Forth: This word has quite another meaning in Forth.

Sets the program counter to the end of the program. Effectively 
quits execution.



R> CORE

Pronunciation: r-from

Compiles to: R> (0)

Stack effects: --- n

Remove the top value from the return stack and leave it on the 
stack.



R'@ TOOLBELT

Compiles to: R> (0)

  I (0)

  SWAP (0)

  >R (0)

Stack effects: --- n

Copy the second return stack item to the stack.



R/O FILE

Pronunciation: r-o

Include: ansfile.4th

Stack effects: --- fam

fam is the implementation-defined value for selecting the read 
only file access method.



R/W FILE

Pronunciation: r-w

Include: ansfile.4th

Stack effects: --- fam

fam is the implementation-defined value for selecting the read 
write file access method.



R@ CORE

Pronunciation: r-fetch

Compiles to: I (0)

Stack effects: --- n

Copy the top of the return stack to the stack.



READ-FILE FILE

Include: ansfile.4th

Stack effects: addr n1 h --- n2 f

Read n1 consecutive characters to addr from the current position 
of the file identified by handle h. If n1 characters are read 
without an exception, flag f is zero and n2 is equal to n1. If 
the end of the file is reached before n1 characters are read, 
flag f is zero and n2 is the number of characters actually read. 
At the conclusion of the operation, FILE-POSITION returns the 
next file position after the last character read.



READ-LINE FILE

Include: ansfile.4th

Stack effects: addr n1 h --- n2 f1 f2

Read the next line from the file specified by handle h into 
memory at the address addr. At most n1 characters are read. Up to 
two implementation-defined line terminating characters may be 
read into memory at the end of the line, but are not included in 
the count n2. The line buffer provided by addr should be at least 
n1+2 characters long. If the operation succeeded, flag f1 is true 
and flag f2 is zero. If a line terminator was received before n1 
characters were read, then n2 is the number of characters, not 
including the line terminator, actually read (0 <= n2 <= n1). 
When n1 = n2 the line terminator has yet to be reached. If the 
operation is initiated when the value returned by FILE-POSITION 
is equal to the value returned by FILE-SIZE for the file 
identified by handle h, flag f1 is false, flag f2 is zero, and n2 
is zero. If flag f2 is non-zero, an exception occurred during the 
operation and f2 is the implementation-defined I/O result code. 
At the conclusion of the operation, FILE-POSITION returns the 
next file position after the last character read.



RECURSE CORE

Compiles to: CALL (<last defined word>)

Compile a call to the current colon-definition inside the current 
colon-definition. If this word is used outside a colon definition 
it is undefined.



REFILL CORE EXT   FILE EXT

Compiles to: REFILL (0)

Stack effects: --- f

Attempt to fill the input buffer from the input source, returning 
a true flag if successful. When the input source is the user 
input device, attempt to receive input into the terminal input 
buffer. When the input source is a text file, attempt to read the 
next line from the text-input file. If successful, make the 
result the input buffer, set >IN to zero, and return true. 
Receipt of a line containing no characters is considered 
successful. If there is no input available from the current input 
source, return false.



RENAME-FILE FILE EXT

Include: ansren.4th

Stack effects: a1 n1 a2 n2 --- f

Forth: Forth usually does a true rename. 4tH copies the original 
file to a new file and deletes the old one.

Rename the ﬁle named by the character string a1 n1 to the name in 
the character string a2 n2. It returns true on error and false on 
success.



REPEAT CORE

Compiles to: BRANCH (<address of matching BEGIN>)

Syntax: BEGIN<space>..<space>WHILE<space>..<space>REPEAT

Forth: Within a BEGIN .. REPEAT construct, multiple WHILEs may be 
used as well, but additional words are necessary to complete the 
construct.

At runtime, REPEAT forces an unconditional branch back to just 
after the corresponding BEGIN. Multiple WHILEs may be used.





REPLACES STRING EXT

Include: substit.4th

Stack effects: a1 n2 a2 n2 ---

Set the string defined by a1 and n1 as the text to substitute for 
the substitution named by a2 and n2. If the substitution does not 
exist it is created. The program may then reuse the buffer a1 n1 
without affecting the definition of the substitution. Ambiguous 
conditions occur as follows:

1. The substitution cannot be created.

2. The name of a substitution contains a delimiter character.



REPOSITION-FILE FILE

Include: ansfile.4th

Stack effects: n h --- f

Reposition the file identified by handle h to n. Flag f is the 
implementation-defined I/O result code. An ambiguous condition 
exists if the file is positioned outside the file boundaries. At 
the conclusion of the operation, FILE-POSITION returns the value 
n.



REPRESENT FLOATING

Include: represnt.4th

Stack effects: addr n1 --- n2 f1 f2

Floating: r ---

At addr, place the character-string external representation of 
the significand of the floating-point number r. The size of the 
buffer identified by addr must be greater than or equal to 
MAXDIGITS and will not be terminated by REPRESENT. Return the 
decimal-base exponent as n2, the sign as f1 and ”valid result” as 
f2. The character string shall consist of the n1 most significant 
digits of the significand represented as a decimal fraction with 
the implied decimal point to the left of the first digit, and the 
first digit zero only if all digits are zero. The significand is 
rounded to n1 digits following the ”round to nearest” rule; n2 is 
adjusted, if necessary, to correspond to the rounded magnitude of 
the significand. If f2 is true then r was in the 
implementation-defined range of floating-point numbers. If f1 is 
true then r is negative. An ambiguous condition exists if the 
value of BASE is not decimal ten.



RESIZE MEMORY

Include: ansmem.4th

  memchar.4th

  memcell.4th

Stack effects: addr1 n --- addr2 f

Change the allocation of the contiguous data space starting at 
the address addr1, previously allocated by ALLOCATE or RESIZE, to 
n address units. n may be either larger or smaller than the 
current size of the region. If the operation succeeds, addr2 is 
the aligned starting address of n address units of allocated 
memory and f is false. The values contained in the region at 
addr1 are copied to addr2, up to the minimum size of either of 
the two regions. If they are the same, the values contained in 
the region are preserved to the minimum of n or the original 
size. If addr2 is not the same as addr1, the region of memory at 
addr1 is returned to the system according to the operation of 
FREE. If the operation fails, addr2 equals addr1, the region of 
memory at addr1 is unaffected, and f is true.



RESTORE-INPUT CORE EXT

Include: evaluate.4th

Stack effects: n1 n2 a1 n3 h n4 --- f

Attempt to restore the input source specification to the state 
described by n1 through h. Flag is true if the input source 
specification cannot be so restored.



REWIND 4TH

Compiles to: LITERAL (0)

  SWAP (0)

  SEEK (0)

Stack effects: h --- f

Reposition the file identified by handle h to the beginning of 
the file. If the operation is successful, FALSE is returned, 
otherwise TRUE.



ROLL CORE EXT

Include: pickroll.4th

Stack effects: nu n1 .. n2 u --- n1 .. n2 nu

Remove u. Rotate u+1 items on the top of the stack.



ROT CORE

Pronunciation: rote

Compiles to: ROT (0)

Stack effects: n1 n2 n3 --- n2 n3 n1

Rotate the top three values on the stack, bringing the third to 
the top.



RP@ 4TH

Compiles to: RP@ (0)

Stack effects: --- sp

Return the address sp of the stack position of the top of the 
return stack as it was before RP@ was executed.



RSHIFT CORE

Pronunciation: r-shift

Compiles to: NEGATE (0)

  SHIFT (0)

Stack effects: n1 n2 --- n3 )

Perform a logical right shift of n2 bit-places on n1, giving n2. 
Put zeroes into the most significant bits vacated by the shift 
(depends on implementation[footnote:
Some C compilers do an arithmetic shift, leaving the most 
significant bit set.
]).



S" CORE   FILE

Pronunciation: s-quote

Compiles to: S" (<address of string constant>)

Syntax: S"<space><string>"

Stack effects: --- addr n

Compiles string delimited by " in the String Segment with an 
execution procedure to move the string to PAD. Leaves the address 
and the length of the string on the stack.



S>D CORE

Pronunciation: s-to-d

Compiler: The instruction pointer is not incremented. In fact, 
S>D is a dummy.

Stack effects: n --- n

Convert the number n to double number n with the same numerical 
value.



S>F FLOATING EXT

Pronunciation: s-to-f

Include: ansfloat.4th

  zenfloat.4th

Stack effects: n ---

Floating: --- r

r is the floating-point equivalent of the single-cell value n.



S| 4TH

Compiles to: S" (<address of string constant>)

Syntax: S|<space><string>|

Stack effects: --- addr n

Compiles string delimited by | in the String Segment with an 
execution procedure to move the string to PAD. Leaves the address 
and the length of the string on the stack.



SAVE-BUFFERS BLOCK

Include: ansblock.4th

  multiblk.4th

Stack effects: ---

Transfer the contents of each UPDATEd block buffer to mass 
storage. Mark the buffer as unmodified.



SAVE-INPUT CORE EXT

Include: evaluate.4th

Stack effects: --- n1 n2 a1 n3 h n4

n1 through h describe the current state of the input source 
specification for later use by RESTORE-INPUT.



SCONSTANT 4TH

Syntax: S"<space><string>"<space>SCONSTANT<space><name>

Compiler: The previously compiled string address is taken as an 
argument for SCONSTANT. The instruction pointer is decremented, 
actually deleting the string address.

A defining word used to create word <name>. When <name> is later 
executed, it will push the current address and the length of the 
string constant on the stack.



SCR BLOCK EXT

Pronunciation: s-c-r

Include: ansblock.4th

  multiblk.4th

Stack effects: --- x

x is the address of a cell containing the block number of the 
block most recently LISTed.



SEARCH STRING

Include: search.4th

Stack effects: addr1 n1 addr2 n2 --- addr3 n3 f

Search the string specified by addr1 n1 for the string specified 
by addr2 n2 . If flag is true, a match was found at addr3 with n3 
characters remaining. If flag is false there was no match and 
addr3 is addr1 and n3 is n1.



SEEK 4TH

Compiles to: SEEK (0)

Stack effects: n h --- f

Reposition the file identified by handle h to n. If n is 
positive, TELL returns the value n. If n is negative, the file is 
repositioned relative to the end of the file. If n equals 
(ERROR), the file is repositioned to the end of the file. If the 
operation is successful, FALSE is returned, otherwise TRUE. 



SET-PRECISION FLOATING EXT

Include: ansfloat.4th

  zenans.4th

Stack effects: n ---

Floating: ---

Set the number of significant digits currently used by F, FE, or 
FS to n.



SHIFT 4TH

Compiles to: SHIFT (0)

Stack effects: n1 n2 --- n3

Performs a logical bit shift on n1. Specifically, SHIFT shifts a 
number a number of bits, specified in n2, using a logical 
register shift.



SIGN CORE

Compiles to: SIGN (0)

Stack effects: n1 n2 --- n2

Stores an ASCII '-' sign just before the converted numeric output 
string in PAD when n1 is negative. n1 is discarded, but n2 is 
maintained. Must be used between <# and #>.



SM/REM CORE

Pronunciation: s-m-slash-rem

Include: mixed.4th

Stack effects: d n1 --- n2 n3

Divide d by n1, giving the symmetric quotient n3 and the 
remainder n2. Input and output stack arguments are signed. An 
ambiguous condition exists if n1 is zero or if the quotient lies 
outside the range of a single-cell signed integer. 



SMOVE 4TH

Compiles to: SMOVE (0)

Stack effects: x1 x2 n ---

Forth: Equivalent to:

  : SMOVE CELLS MOVE ;

Move the specified quantity of cells (n) beginning at address x1 
to x2.



SOURCE CORE

Compiles to: LITERAL (<address of TIB variable>)

  @ (0)

  LITERAL (<address of TIB-size variable>)

  @ (0)

Stack effects: --- addr n

addr is the address of, and n is the number of characters in, the 
currently used TIB.



SOURCE! SOURCEFORGE

Compiles to: LITERAL (<address of TIB-size variable>)

  ! (0)

  LITERAL (<address of TIB variable>)

  ! (0)

Stack effects: addr n ---

Forth: In Forth, >IN is set to zero. In 4tH this is left up to 
the application programmer.

Make the string described by c-addr and u the current input 
buffer. A program is allowed to refill the input buffer without 
restoring the original input source; upon a refill, the system 
shall accept the new portion of text to the current refill buffer 
and make it the input buffer.



SOURCE-ID CORE EXT   FILE

Pronunciation: source-i-d

Compiles to: ENVIRON (<address of CIN>)

Stack effects: --- n

Identifies the input source.



SP@ 4TH

Compiles to: SP@ (0)

Stack effects: --- sp

Return the address sp of the stack position of the top of the 
stack as it was before SP@ was executed.



SPACE CORE

Compiles to: LITERAL (<ASCII value of space>)

  EMIT (0)

Transmit an ASCII blank to the current output device.



SPACES CORE

Compiles to: SPACES (0)

Stack effects: n ---

Transmit n ASCII blanks to the current output device.



SPAN CORE EXT

Include: obsolete.4th

Stack effects: --- x

X is the address of a cell containing the count of characters 
stored by the last execution of EXPECT (see EXPECT).



STACK-CELLS 4TH

Compiles to: LITERAL (<number of integers>)

Stack effects: --- n

Forth: Equivalent to:

  : STACK-CELLS S" STACK-CELLS" ENVIRONMENT? DROP ;

Returns the number of integers that the Stack Area can contain. 
Both stacks share the Stack Area.



STDIN 4TH

Compiles to: LITERAL (<address of stream>)

Stack effects: --- h

Leaves a filehandle on the stack associated with the standard 
keyboard input device. This stream cannot be closed.



STDOUT 4TH

Compiles to: LITERAL (<address of stream>)

Stack effects: --- h

Leaves a filehandle on the stack associated with the standard 
screen output device. This stream cannot be closed.



STRING 4TH

Syntax: <literal><space>STRING<space><name>

Compiler: The previously compiled literal is taken as an argument 
for STRING. The instruction pointer is decremented, actually 
deleting the literal.

Forth: This word is 4tH specific. Roughly equivalent to:

  : STRING CREATE CHARS ALLOT ;

Allocate <literal> characters of contiguous data space beginning 
at <name> in the Character Segment. The initial content of the 
allocated space is undefined.



STRUCT 4TH

Compiles to: LITERAL (0)

Syntax: 
STRUCT<space><literal><space>+FIELD<space><name><space>END-STRUCT<space><name>

  
STRUCT<space><literal><space>/FIELD<space>END-STRUCT<space><name>

Stack effects: --- n

Forth: Similar constructions are available in GForth. +FIELD is 
part of the Forth 200x draft.

A constant, which initiates a STRUCT definition (see: +FIELD, 
/FIELD, END-STRUCT).



SUBSTITUTE STRING EXT

Include: substit.4th

Stack effects: a1 n1 a2 n2 -- a2 n3 n4 

Perform substitution on the string at a1 and n1 placing the 
result at string a2 and n2, returning a2 and n3, the length of 
the resulting string. An ambiguous condition occurs if the 
resulting string will not fit into a2 n2 or if a2 is the same as 
a1. The return value n4 is positive (0..+n) on success and 
indicates the number of substitutions made. A negative value for 
n4 indicates that an error occurred, leaving a2 and n3 undefined. 
Substitution occurs from the start of a1 and n1 in one pass and 
is non-recursive. When a substitution name surrounded by '%' 
delimiters is encountered by SUBSTITUTE, the following occurs:

1. If the name is null, a single delimiter character is 
  substituted, i.e. %% is replaced by %.

2. If the name is a valid substitution name, the leading and 
  trailing delimiter characters and the enclosed substitution 
  name are replaced by the substitution text.

3. If the name is not a valid substitution name, the name with 
  leading and trailing delimiters is passed unchanged to the 
  output.



SWAP CORE

Compiles to: SWAP (0)

Stack effects: n1 n2 --- n2 n1

Exchange the top two values on the stack.



SYNC 4TH

Compiles to: SYNC (0)

Stack effects: ---

Attempt to force any buffered information written to the device 
referred to by the output channel to be written.



TABLE 4TH

Syntax: TABLE<space><name>

Forth: Available in some Forths.

Leaves <name> in the symboltable and replace further occurences 
with LITERAL <xt>. <xt> represents the address in the Code 
Segment where TABLE was compiled. An alias for CREATE.



TAG 4TH

Syntax: TAG<space><name1><space><name2>

Forth: This word is 4tH specific. Roughly equivalent to:

  : TAG ' >BODY 1 CELLS - CREATE , DOES> DUP @ - ;

Create a CONSTANT <name2> which contains the difference in 
characters between the current address of the String Segment and 
previously defined OFFSET <name1>. This constant can be used as 
an index to <name1> to retrieve any binary strings defined 
directly after the definition of <name2>.



TELL 4TH

Compiles to: TELL (0)

Stack effects: h --- n

n is the current file position for the file identified by handle 
h. 



TH COMUS

Compiles to: + (0)

Stack effects: x1 n --- x2

Forth: This word is not part of ANS-Forth or Forth-79, but can be 
found in other Forths. It can be very handy when porting 4tH 
programs. Just define TH as:

  : TH CELLS + ;

  When you're using a construction like:

  VAR 2 TH

  In both 4tH and Forth the third element will be referenced. The 
use of TH to reference an element of a string in the Character 
Segment is allowed in 4tH, but the resulting source cannot be 
ported to Forth.

Used to reference an element in an array of integers. Will return 
the address of the n-th element in array x1 as x2. An alias for 
+.



THEN CORE

Syntax: IF<space>..<space>ELSE<space>..<space>THEN

At runtime THEN serves only as the destination of a forward 
branch from IF or ELSE. It marks the conclusion of the 
conditional structure.



THROW EXCEPTION

Compiles to: THROW (0)

Stack effects: n ---

Forth: The values of THROW are not conforming the ANS-Forth 
standard.

If n is non-zero, pop the topmost exception frame from the return 
stack, along with everything beyond that frame. Then adjust the 
return- and datastacks so they are the same as the depths saved 
in the exception frame, put n on top of the data stack, and 
transfer control to a point just after the CATCH that pushed that 
exception frame (see: CATCH).



TIB CORE EXT

Pronunciation: t-i-b

Compiles to: LITERAL (<address of Terminal Input Buffer>)

Stack effects: --- addr

Forth: In Forth this is a variable. However, it is unlikely 
you'll ever find a program which assigns another value to it.

A constant which leaves the address of the Terminal Input Buffer 
on the stack.



TIME 4TH

Compiles to: TIME (0)

Stack effects: --- n

Returns the number of seconds since January 1st, 1970.



TIME&DATE FACILITY

Pronunciation: time-and-date

Include: ansfacil.4th

Stack effects: --- n1 n2 n3 n4 n5 n6

Return the current time and date. n1 is the second {0...59}, n2 
is the minute {0...59}, n3 is the hour {0...23}, n4 is the day 
{1...31}, n5 is the month {1...12}, and n6 is the year (e.g., 
1991).



TO CORE EXT

Compiles to: TO (<variable address>)

Stack effects: n ---

Syntax: TO<space><name>

Store n in the value identified by name.



TRUE CORE EXT

Compiles to: LITERAL (<flag>)

Stack effects: --- f

Forth: In ANS-Forth TRUE is represented by a -1 value.

Returns a true flag on the stack.



TUCK CORE EXT

Compiles to: SWAP (0)

  OVER (0)

Stack effects: n1 n2 --- n2 n1 n2 )

Copy the first (top) stack item below the second stack item.



TYPE CORE

Compiles to: TYPE (0)

Stack effects: addr n ---

Transmit n characters from addr to the selected output device.



U. CORE

Pronunciation: u-dot

Include: dbldot.4th

Stack effects: n --- 

Display n in free field format as an unsigned number.



U.R CORE EXT

Pronunciation: u-dot-r

Include: dbldot.4th

Stack effects: n1 n2 --- 

Display unsigned number n1 right aligned in a field n2 characters 
wide. If the number of characters required to display n1 is 
greater than n2, all digits are displayed with no leading spaces 
in a field as wide as necessary. 



U< CORE

Pronunciation: u-less-than

Include: ansdbl.4th

Stack effects: n1 n2 --- f 

Flag f is true if and only if unsigned number n1 is less than 
unsigned number n2.



U> CORE EXT

Pronunciation: u-greater-than

Include: ansdbl.4th

Stack effects: n1 n2 --- f 

Flag f is true if and only if unsigned number n1 is greater than 
unsigned number n2.



UM* CORE

Pronunciation: u-m-star

Include: mixed.4th

Stack effects: n1 n2 --- d 

Multiply n1 by n2, giving the unsigned double-cell product d. All 
values and arithmetic are unsigned. 



UM/MOD CORE

Pronunciation: u-m-slash-mod

Include: mixed.4th

Stack effects: d n1 --- n2 n3 

Divide d by n1, giving the quotient n3 and the remainder n2. All 
values and arithmetic are unsigned. An ambiguous condition exists 
if n1 is zero or if the quotient lies outside the range of a 
single-cell unsigned integer.



UNESCAPE STRING EXT

Include: substit.4th

Stack effects: a1 n1 a2 -- a2 n2 

Replace each '%' character in the input string a1 n1 by two '%' 
characters. The output is represented by a2 n2. The buffer at a2 
must be big enough to hold the unescaped string.



UNLOOP CORE

Compiles to: R> (0)

  R> (0)

  DROP (0)

  DROP (0)

Stack effects: ---

Discard the loop-control parameters for the current nesting 
level. An UNLOOP is required for each nesting level before the 
definition may be EXITed.



UNTIL CORE

Compiles to: 0BRANCH (<address of matching BEGIN>)

Stack effects: f ---

Syntax: BEGIN<space>..<space>WHILE<space>..<space>UNTIL

Forth: The optional WHILE word is not supported.

At runtime UNTIL controls the conditional branch back to the 
corresponding BEGIN. If f is FALSE execution returns to just 
after BEGIN; if f is TRUE execution continues ahead.



UPDATE BLOCK

Include: ansblock.4th

  multiblk.4th

Stack effects: ---

Mark the current block buffer as modified. An ambiguous condition 
exists if there is no current block buffer. UPDATE does not 
immediately cause I/O.



USE 4TH

Compiles to: USE (0)

Stack effects: h ---

USE will associate the stream identified by filehandle h with the 
appropriate input- or output-channel, depending on the file 
access method used when opening the stream (see: OPEN). No 
streams are closed.



VALUE CORE EXT

Compiles to: TO (<variable address>)

Stack effects: n ---

Syntax: <literal><space>VALUE<space><name>

Create a symboltable entry for the value name with an initial 
value n. At runtime, n will be placed on the stack. In 4tH it is 
an alias for TO.



VARIABLE CORE

Syntax: VARIABLE<space><name>

A defining word used to create variable <name>. When <name> is 
later executed, it will push the address <var> on the stack, so 
that a fetch or store may access this location.



VARS 4TH

Compiles to: VARS (0)

Stack effects: --- x

This word returns the begin of the variables area.



W/O FILE

Pronunciation: w-o

Include: ansfile.4th

Stack effects: --- fam

fam is the implementation-defined value for selecting the write 
only file access method.



WHILE CORE

Compiles to: 0BRANCH (<address of matching REPEAT token>)

Stack effects: f ---

Syntax: BEGIN<space>..<space>WHILE<space>..<space>REPEAT

  BEGIN<space>..<space>WHILE<space>..<space>UNTIL

Forth: Within a BEGIN .. REPEAT construct, multiple WHILEs may be 
used as well, but additional words are necessary to complete the 
construct.

At runtime, WHILE selects conditional execution based on number 
n. If f is TRUE, WHILE continues execution of the code thru to 
REPEAT, which branches back to BEGIN. If f is FALSE, execution 
skips to just after REPEAT, exiting the structure. Multiple 
WHILEs may be used.



WIDTH 4TH

Compiles to: LITERAL (<number of characters>)

Stack effects: --- n

A constant which leaves the maximum number of characters, allowed 
in a <name> label.



WITHIN CORE EXT

Include: range.4th

Stack effects: n1 n2 n3 --- f

Perform a comparison of a test value n1 with a lower limit n2 and 
an upper limit n3 , returning true if either (n2 < n3 and (n2 <= 
n1 and n1 < n3)) or (n2 > n3 and (n2 <= n1 or n1 < n3)) is true, 
returning false otherwise.



WORD CORE

Include: word.4th

Stack effects: c --- addr 

Skip leading delimiters and parse characters delimited by c. Addr 
is the address of the parsed word. If the parse area was empty or 
contained no characters other than the delimiter, the resulting 
string has a zero length.



WRITE-FILE FILE

Include: ansfile.4th

Stack effects: addr n h --- f

Write n characters from addr to the file identified by handle h 
starting at its current position. Flag f is the 
implementation-defined I/O result code. At the conclusion of the 
operation, FILE-POSITION returns the next file position after the 
last character written to the file, and FILE-SIZE returns a value 
greater than or equal to the value returned by FILE-POSITION.



WRITE-LINE FILE

Include: ansfile.4th

Stack effects: addr n h --- f

Write n characters from addr followed by the 
implementation-dependent line terminator to the file identified 
by handle h starting at its current position. Flag f is the 
implementation-defined I/O result code. At the conclusion of the 
operation, FILE-POSITION returns the next file position after the 
last character written to the file, and FILE-SIZE returns a value 
greater than or equal to the value returned by FILE-POSITION.



X-SIZE XCHAR

Include: xchar.4th

Stack effects: addr n1 --- n2

n2 is the number of chars used to encode the first xchar stored 
in the string addr n1. To calculate the size of the xchar, only 
the bytes inside the buffer may be accessed. An ambiguous 
condition exists if the xchar is incomplete or malformed. 



X-WIDTH XCHAR EXT

Include: xchar.4th

Stack effects: addr n1 --- n2

n2 is the number of monospace ASCII characters that take the same 
space to display as the the xchar string addr n1; assuming a 
monospaced display font, i.e. xchar width is always an integer 
multiple of the width of an ASCII character. 



X\STRING- XCHAR EXT

Include: xchar.4th

Stack effects: addr n1 --- addr1 n2

Search for the penultimate xchar in the string addr1 n1. The 
string addr1 n2 contains all xchars of addr n1, but the last. 
Unlike XCHAR-, X\STRING- can be implemented in encodings where 
xchar boundaries can only reliably detected when scanning in 
forward direction.



XC-SIZE XCHAR

Include: xchar.4th

Stack effects: addr --- n

n is the number of pchars used to encode xchar in memory. 



XC-WIDTH XCHAR EXT

Include: xchar.4th

Stack effects: n1 --- n2

n2 is the number of monospace ASCII characters that take the same 
space to display as the xchar; i.e. xchar width is always an 
integer multiple of the width of an ASCII char. 



XC@+ XCHAR

Include: xchar.4th

Stack effects: addr1 --- addr2 n

Fetches the xchar at addr1. addr2 points to the first memory 
location after the retrieved xchar. 



XC!+ XCHAR

Include: xchar.4th

Stack effects: n addr1 --- addr2

Stores the xchar at addr1. addr2 points to the first memory 
location after the stored xchar.



XC!+? XCHAR

Include: xchar.4th

Stack effects: n1 addr1 n2 --- addr2 n3 f

Stores the xchar into the string buffer specified by addr1 n2. 
addr2 n3 is the remaining string buffer. If the xchar did fit 
into the buffer, flag is true, otherwise flag is false, and addr2 
n3 equal addr1 n2. XC!+? is safe for buffer overflows.



XCHAR+ XCHAR

Include: xchar.4th

Stack effects: addr1 --- addr2

Adds the size of the xchar stored at addr1 to this address, 
giving addr2.



XCHAR- XCHAR EXT

Include: xchar.4th

Stack effects: addr1 --- addr2

Goes backward from addr1 until it finds an xchar so that the size 
of this xchar added to addr2 gives addr1. There is an ambiguous 
condition when the encoding doesn't permit reliable backward 
stepping through the text. 



XEMIT XCHAR

Include: xchar.4th

Stack effects: n ---

Prints an xchar on the terminal.



XHOLD XCHAR EXT

Include: xchar.4th

Stack effects: n ---

Adds an xchar to the picture numeric output buffer. 



XOR CORE

Pronunciation: x-or

Compiles to: XOR (0)

Stack effects: n1 n2 --- n3

Leave the bitwise logical XOR of n1 XOR n2 as n3.



['] CORE

Pronunciation: bracket-tick

Compiles to: LITERAL (<tok>)

Syntax: [']<space><name>

Stack effects: --- n | x | xt

Forth: See '.

Compile the value contents of the symboltable entry identified as 
symbol <name> as a literal. An alias for '.





[: COMP.LANG.FORTH

Compiles to: LITERAL (<address of next BRANCH>)

  BRANCH (<address of matching ; token>)

Syntax: [:<space>..<space>;]

Stack effects: --- xt

Forth: Several Forths support this word, e.g. gForth, iForth and 
VFX Forth.

Suspends compiling to the current definition (if any), starts a 
new nested definition, and compilation continues with this nested 
definition. 





[=] 4TH

Compiles to: LITERAL (<flag>)

Syntax: <literal><space><literal><space>[=]

Compiler: Two previously compiled literals are taken as arguments 
and a true flag is recompiled when they are equal. The 
instruction pointer is decremented, actually deleting the 
literals.

Stack effects: --- f

Forth: Equivalent to =.





[ABORT] 4TH

Forth: Roughly equivalent to:

  [ ABORT ]

Compilation is aborted immediately.



[ASSERT] 4TH

Toggles assertions. Assertions are disabled by default (see: 
ASSERT( and ) ).



[BINARY] 4TH

Forth: Roughly equivalent to:

  [ 2 BASE ! ]

When encountered during compilation it will set the radix to 
binary. All subsequent literals will be interpreted as binary 
numbers. Runtime behaviour will be controlled by HEX, OCTAL and 
DECIMAL.



[CHAR] CORE

Pronunciation: bracket-char

Compiles to: LITERAL (<ASCII-value of character>)

Syntax: [CHAR]<space><char>

Stack effects: --- c

Compiles the ASCII-value of <char> as a literal. At runtime the 
value is thrown on the stack. An alias for CHAR.



[DECIMAL] 4TH

Forth: Roughly equivalent to:

  [ DECIMAL ]

When encountered during compilation it will set the radix to 
decimal. All subsequent literals will be interpreted as decimal 
numbers. Runtime behaviour will be controlled by HEX, OCTAL and 
DECIMAL.



[DEFINED] SEARCH EXT

Compiles to: LITERAL (<flag>)

Stack effects: --- f

Syntax: [DEFINED]<space><name>

If the name is defined, return TRUE, else return FALSE.



[ELSE] TOOLS EXT

Pronunciation: bracket-else

Syntax: 
<literal><space>[IF]<space><word>..[ELSE]<space><word>..[THEN]

Skipping leading spaces, parse and discard space-delimited words 
from the parse area, including nested occurrences of [IF] ... 
[THEN] and [IF] ... [ELSE] ... [THEN], until the word [THEN] has 
been parsed and discarded.



[FORCE] 4TH

Disables all optimization for the compilation of one single word.



[HEX] 4TH

Forth: Roughly equivalent to:

  [ HEX ]

When encountered during compilation it will set the radix to 
hexadecimal. All subsequent literals will be interpreted as 
hexadecimal numbers. Runtime behaviour will be controlled by HEX, 
OCTAL and DECIMAL.



[IF] TOOLS EXT

Pronunciation: bracket-if

Syntax: 
<literal><space>[IF]<space><word>..[ELSE]<space><word>..[THEN]

Compiler: The previously compiled literal is taken as an argument 
for [IF]. The instruction pointer is decremented, actually 
deleting the literal.

Forth: Forth pops a value from the stack. This is not possible in 
4tH.

If flag is true, do nothing. Otherwise, skipping leading spaces, 
parse and discard space-delimited words from the parse area, 
including nested occurrences of [IF] ... [THEN] and [IF] ... 
[ELSE] ... [THEN], until either the word [ELSE] or the word 
[THEN] has been parsed and discarded. 



[IGNORE] 4TH

Syntax: [IGNORE]<space><name>

Compiler: The name is added to the symboltable. Subsequent 
occurrences of the name will be ignored.

Forth: Roughly equivalent to:

  : [ignore] create does> drop ;

Recognize name, but do not perform any action or compile any code 
for it.





[MAX] 4TH

Compiles to: LITERAL (<max>)

Syntax: <literal><space><literal><space>[MAX]

Compiler: Two previously compiled literals are taken as 
arguments, the larger one of the two is recompiled. The 
instruction pointer is decremented, actually deleting the 
literals.

Stack effects: --- n

Forth: Equivalent to MAX.





[NEEDS 4TH

Syntax: [NEEDS<space><string>]

Compiler: The contents of the file are inserted at this position.

Open the file specified by <string> and include its contents at 
the current position. When the end of the file is reached, close 
the file and continue compilation. An error condition exists if 
the named file can not be opened, if an I/O exception occurs 
reading the file, or if an I/O exception occurs while closing the 
file.





[NOT] 4TH

Compiles to: LITERAL (<flag>)

Syntax: <literal><space>[NOT]

Compiler: A previously compiled literal is taken as an argument 
and a true flag is recompiled when it is equal to zero. The 
instruction pointer is decremented, actually deleting the 
literal.

Stack effects: --- f

Forth: Equivalent to 0=.





[OCTAL] 4TH

Forth: Roughly equivalent to:

  [ 8 BASE ! ]

When encountered during compilation it will set the radix to 
octal. All subsequent literals will be interpreted as octal 
numbers. Runtime behaviour will be controlled by HEX, OCTAL and 
DECIMAL.



[PRAGMA] 4TH

Syntax: [PRAGMA]<space><name>

A defining word used to create word <name>. When <name> is later 
executed, it will push the value TRUE on the stack. Intended to 
define pragmas for use in an include file.

[SIGN] 4TH

Compiles to: LITERAL (<sign>)

Syntax: <literal><space>[SIGN]

Compiler: A previously compiled literal is taken as an argument, 
and its sign recompiled. The instruction pointer is decremented, 
actually deleting the literal.

Stack effects: --- -1|0|1

Used to convert a previously compiled literal to a single value, 
leaving only its sign.





[THEN] TOOLS EXT

Pronunciation: bracket-then

Does nothing. Acts as a marker for [IF] (see: [IF]).



[UNDEFINED] SEARCH EXT

Compiles to: LITERAL (<flag>)

Stack effects: --- f

Syntax: [UNDEFINED]<space><name>

If the name is defined, return FALSE, else return TRUE.



\ CORE EXT

Pronunciation: backslash

Syntax: \<space><string>

The remainder of the line is discarded. Used for comment.

Editor manual

16.1 Introduction 

Forth organises its mass storage into "screens" of 1024 
characters. Forth may have one screen in memory at a time for 
storing text. The screens are numbered, starting with screen 0.

Each screen is organised as 16 lines with 64 characters. The 
Forth screens are merely an arrangement of virtual memory and do 
not correspond to the screen format of the target machine. Due to 
this format, the use of the comment word '\' is not allowed. Use 
'(' instead.

16.2 Selecting a screen and input of text 

After you've started an editing session, you need to select a 
screen to edit. The screen is given a number and selected by 
using:

n CLEAR (clear screen n and select for editing).

To input new text to screen after CLEAR, the P (put) command is 
used. Example:

0 P THIS IS HOW 

1 P TO INPUT TEXT 

2 P TO LINES 0, 1, 2 OF SELECTED SCREEN.

16.3 Line editing 

During this description of the editor, reference is made to PAD. 
This is a text buffer which may hold a line of text to be found 
or deleted by a string editing command. Do not confuse this PAD 
with 4tHs PAD. It is only called that way by convention.

16.4 Line editing commands 

n D Delete line n but hold it in PAD. Line 15 becomes free as all 
statements move up 1 line. 

n E Erase line n with blanks. 

n I Insert the text from PAD at line n, moving the old line n and 
following lines down. Line 15 is lost. 

n H Hold line n at PAD (used by system more often than by user). 

n R Replace line n with the text in PAD. 

n S Spread at line n. Line n and following lines move down 1 
line. Line n becomes blank. Line 15 is lost. 

n T Display line n and copy it to PAD. 

n P text Put 'text' at line n, overwriting its previous contents.

16.5 Screen editing commands 

n LIST List screen n and select it for editing: if screen n is 
not the current screen, it will request to load from memory. 

n CLEAR Clear screen n with blanks and select it for editing. 

n INSERT Insert screen n. The current screen n and all screens 
following it are moved down. The last screen is lost.

n m COPY Copy the contents of screen n to screen m. The original 
contents of screen m are lost.

FLUSH Used at the end of an editing session to save the current 
screen to memory. 

UNDO Used to reload the current screen again, thus undoing all 
changes since the last flush (triggered by CLEAR, FLUSH or LIST). 

L List the current screen. The cursor line is relisted after the 
screen listing to show the cursor position.

16.6 Cursor control and string editing 

The screen of text being edited resides in a buffer area of 
storage. The editing cursor is a variable holding an offset into 
this buffer area. Commands are provided from the user to position 
the cursor either directly or by searching for a string of buffer 
text, and to insert or delete text at the cursor position.

16.7 Commands to position the cursor 

n M Move the cursor by n characters and the cursor line. The 
position of the cursor on its line is shown by a ^ (caret). 

n W Wipe n characters to the left of the cursor. 

TOP Position the cursor at the start of the screen.

16.8 String editing commands 

B Used after F to back up the cursor by the length of the most 
recent text. 

C text Copy in text to the cursor line at the cursor position. 

F text Search forward from the current cursor position until 
string 'text' is found. The cursor is left at the end of the 
string and the cursor line printed. If the string is not found an 
error message is given and the cursor repositioned to the top of 
the screen. 

N Find the next occurrence of the string found by an F command 

TlLL text Delete on the cursor line from the cursor till the end 
of string text. 

X text Find and delete the next occurrence of the string 'text'.

16.9 Saving and exiting

WRITE Saves the current contents of all screens to the 
block-file. No flushing is done.

WQ Flushes the current screen and saves the current contents of 
all screens to the block-file. 

Q Quits the editor without saving.

EXPORT name Saves the current contents of all screens to the 
text-file with the name 'name'. No flushing is done. 

16.10 Calculator mode

The calculator mode is a simulation of what is known as the 
"Forth calculator mode". You can use it to try out a host of 4tH 
words in interactive mode. It also serves nicely as a 
deskcalculator. You can freely mix editor and calculator 
commands.

We tried to include as many 4tH words as possible, although we 
had to modify some due to the limitations imposed by the system. 
There are eight pre-defined user-variables called "A." though 
"H.". You can use these variables like any other user-variable.

You cannot declare new variables or make any colon-definitions in 
interactive mode. If you are unclear how to use the built-in 
calculator please refer to the Primer and the Glossary. By 
convention, calculator mode uses "OK" as the prompt. The 
following table shows you which commands are available:[float Table:

+-------------+-----------------++---------------+----------------+
| Editor      |  4tH equivalent || Editor        | 4tH equivalent |
+-------------+-----------------++---------------+----------------+
+-------------+-----------------++---------------+----------------+
| +           |  +              || @             | @              |
+-------------+-----------------++---------------+----------------+
| th          |  th             || ?             | ?              |
+-------------+-----------------++---------------+----------------+
| -           |  -              || base!         | base !         |
+-------------+-----------------++---------------+----------------+
| *           |  *              || decimal       | decimal        |
+-------------+-----------------++---------------+----------------+
| /           |  /              || octal         | octal          |
+-------------+-----------------++---------------+----------------+
| q           |  quit           || binary        | 2 base !       |
+-------------+-----------------++---------------+----------------+
| quit        |  quit           || .( <string>)  | .( <string>)   |
+-------------+-----------------++---------------+----------------+
| bye         |  quit           || mod           | mod            |
+-------------+-----------------++---------------+----------------+
| .           |  .              || abs           | abs            |
+-------------+-----------------++---------------+----------------+
| .r          |  .r             || negate        | negate         |
+-------------+-----------------++---------------+----------------+
| drop        |  drop           || invert        | invert         |
+-------------+-----------------++---------------+----------------+
| dup         |  dup            || min           | min            |
+-------------+-----------------++---------------+----------------+
| rot         |  rot            || max           | max            |
+-------------+-----------------++---------------+----------------+
| swap        |  swap           || or            | or             |
+-------------+-----------------++---------------+----------------+
| over        |  over           || and           | and            |
+-------------+-----------------++---------------+----------------+
| A.          |  variable a. a. || xor           | xor            |
+-------------+-----------------++---------------+----------------+
| B.          |  variable b. b. || lshift        | lshift         |
+-------------+-----------------++---------------+----------------+
| C.          |  variable c. c. || rshift        | rshift         |
+-------------+-----------------++---------------+----------------+
| D.          |  variable d. d. || depth         | depth          |
+-------------+-----------------++---------------+----------------+
| E.          |  variable e. e. || cells         | cells          |
+-------------+-----------------++---------------+----------------+
| F.          |  variable f. f. || 1+            | 1+             |
+-------------+-----------------++---------------+----------------+
| G.          |  variable g. g. || cell+         | cell+          |
+-------------+-----------------++---------------+----------------+
| H.          |  variable h. h. || 1-            | 1-             |
+-------------+-----------------++---------------+----------------+
| !           |  !              || cell-         | cell-          |
+-------------+-----------------++---------------+----------------+
| +!          |  +!             || space         | space          |
+-------------+-----------------++---------------+----------------+
| ( <string>) |  ( <string>)    || spaces        | spaces         |
+-------------+-----------------++---------------+----------------+
| cr          |  cr             || 2*            | 2*             |
+-------------+-----------------++---------------+----------------+
| time        |  time           || 2/            | 2/             |
+-------------+-----------------++---------------+----------------+
| char        |  char           || /mod          | /mod           |
+-------------+-----------------++---------------+----------------+
| [char]      |  [char]         || */            | */             |
+-------------+-----------------++---------------+----------------+
| emit        |  emit           || */mod         | */mod          |
+-------------+-----------------++---------------+----------------+


[Senseless!!! 
DC commands
]
]

Shell manual

17.1 Introduction

The 4tsh shell is a multitasking environment for 4tH. 4tH 
features cooperative multitasking, which means programs have to 
relinquish control to the shell using 'PAUSE', otherwise the 
program will keep in control. The best place to add 'PAUSE' is 
usually somewhere in a loop. 4tH comes with several example 
multitasking programs for you to try out. 4tsh can be used as a 
command line replacement for 4th, since you can enable 
multitasking in the editor.

4tsh is scriptable. Scripts are stored in blockfiles, because 
block I/O is completed within a single context. If you prefer to 
use your own editor, you need to convert your script to a 
blockfile. 4tH comes with a conversion program, called 
txt2blk.4th. Every twelve lines are converted to a block, leaving 
four additional lines for future modifications. Your lines should 
be limited to 63 characters or less.

When a script it loaded, the first block is executed 
automatically. By convention, the first block is block 0. When 
the execution of a block has completed, the script stops. You can 
call other blocks by using ”LOAD”. When the execution of a called 
block has completed, the execution of the previous block will 
resume at the point where execution was transferred to the called 
block. It is recommended to use the first block as an application 
load screen[footnote:
See ”Thinking Forth”, chapter 5.
], e.g.

( 4tsh application load screen)

1 load  ( initialization)

2 load  ( checking conditions)

3 load  ( error handling)

An application load screen is simply a block that consecutively 
loads all the blocks that make up your script. You can run an 
arbitrary number of scripts at startup by issuing them on the 
command line, e.g.

4tsh boot.scr startup.scr tasks.scr

When all scripts have finished execution, control will 
automatically be transferred to the monitor.

17.2 Loading and saving

load” s” Loads HX file s from disk and leaves the task number on 
the stack.

compile” s” Loads and compiles source file s and leaves the task 
number on the stack.

n save” s” Saves task number n to HX file s.

n write” s” Generates C source file s from task number n.

n1 n2 see Decompiles task number n1 from opcode n2 on.

17.3 Task management

task Leaves the task number of the current monitor on the stack.

boot Starts a new monitor and runs the boot scripts.

pause Deactivates the monitor for one cycle.

n pauses Deactivates the monitor for n cycles.

n run Awakes and switches to task number n.

n awake Awakes task number n.

n sleep Deactivates task number n, but leaves it in memory.

n kill Deactivates task number n and removes it from memory.

tasks Lists all tasks.

halt Kills all tasks and shuts down 4tsh.

17.4 Scripting

script” s" Run script s. Does only work in interactive mode.

n load Load and interpret block n. Does not work in interactive 
mode.

:: s Define label s.

goto s Goto label s. Works in interactive mode, but only if s 
resides on the same line.

n if Execute the words between if and the corresponding then, but 
only if n is non-zero. Works in interactive mode. If you fail to 
provide a corresponding then you will be prompted to provide it 
manually.

then Marker for if.

n not Leaves a non-zero value on the stack if n is zero, 
otherwise zero.

n status Leaves the status of task number n on the stack.

done Constant holding the termination status returned by status.

running Constant holding the active status returned by status.

sleeping Constant holding the inactive status returned by status.

17.5 Stack, I/O and arithmetic

[float Table:

+-------+----------------++-------+----------------+
| 4tsh  | 4tH equivalent || 4tsh  | 4tH equivalent |
+-------+----------------++-------+----------------+
+-------+----------------++-------+----------------+
|  +    | +              ||  .    |       .        |
+-------+----------------++-------+----------------+
|  -    | -              || dup   |      dup       |
+-------+----------------++-------+----------------+
|  *    | *              || rot   |      rot       |
+-------+----------------++-------+----------------+
|  /    | /              || over  |      over      |
+-------+----------------++-------+----------------+
|  cr   | cr             || swap  |      swap      |
+-------+----------------++-------+----------------+
|  .(   | .(             || drop  |      drop      |
+-------+----------------++-------+----------------+
|  (    | (              ||  =    |       =        |
+-------+----------------++-------+----------------+


[Senseless!!! 
4tsh commands
]
]

<cha:Preprocessor-manual>Preprocessor manual

18.1 Introduction

The preprocessor is a tool written in 4tH that has the following 
features:

• It expands special macro definitions. These macro definitions 
  can contain anything you want;

• It strips whitespace and comments;

• It collects all include files and inserts them into the source;

• It expands [CHAR] and CHAR constructs.

This tool can help you to solve several problems:

• Your 4tH implementation has serious memory restrictions, so 
  certain sources cannot be compiled;

• You have to port Forth programs that use complex jump 
  constructs.

• You have to write Forth compatible programs without the use of 
  easy.4th;

• You can simplify development by writing complex programs more 
  easily;

• You need to inline code in a structured way;

• It may serve in some situations as a debugging tool.

Note that the preprocessor is just a tool to automate certain 
sourcecode manipulations. It doesn't compile anything, although 
it does perform some syntax checks[footnote:
The preprocessor is sometimes even more pedantic than 4tH itself, 
see section [sec:Bugs-and-limitations].
]. Succesfully processed source can be rejected by the compiler 
for any number of reasons.

Every valid 4tH program is automatically valid 4tH preprocessor 
source. In addition the preprocessor supports special 
preprocessor words, which are listed below.

18.2 Macros

A macro starts with the word :MACRO and is delimited by a 
semi-colon like a normal definition. A macro may span several 
lines and may contain anything you want, including conditional 
and loop statements. Macros may be nested, but they may not 
contain certain directives.

This ANS Forth definition is impossible to define in 4tH:

: STEP 8 POSTPONE LITERAL POSTPONE +LOOP ;

In the preprocessor you can define it like this:

:MACRO STEP 8 +LOOP ;

Macros are expanded by the preprocessor which means that every 
time it finds ”STEP” it will be replaced by ”8 +LOOP”.

18.2.1 Back quoted strings

You can't print a semi-colon inside a macro, because it will be 
interpreted to be the end of the macro. In order to defeat the 
interpreter you can use back quoted strings. Back quoted strings 
are printed verbatim, so this will work:

:macro extra_stack : dip over swap ` ;` ;

You can even define entire strings:

:macro nul? dup 0= ` abort" Missing string"` ;

Note that back quoted strings are only interpreted within macros. 
Outside macros they are ignored.

18.2.2 Registers

The preprocessor has 4 global registers, which can only be used 
inside macro definitions. Take this definition:

:MACRO MONTH @1@ @2@ CREATE #1# #2# , DOES> @C . ` ;` ;

MONTH SEPTEMBER 9

Will expand to:

CREATE SEPTEMBER 9 , DOES> @C . ;

The commands @1@ through @4@ parse a word and store it in 
register 1 through 4. The commands #1# though #4# print the 
string stored there. Registers retain their values between calls, 
e.g.:

:MACRO BEGIN-STRUCTURE @1@ STRUCT ;

:MACRO END-STRUCTURE END-STRUCT #1# ;

  

BEGIN-STRUCTURE point

  1 CELLS +FIELD p.x

  1 CELLS +FIELD p.y

END-STRUCTURE

Will expand to:

STRUCT

  1 CELLS +FIELD p.x

  1 CELLS +FIELD p.y

END-STRUCT point

18.2.3 Parsing strings

Strings can be parsed by using the $1$ through $4$ commands and 
store them in register 1 through 4. They always have to be 
followed by a delimiter, e.g.:

INCLUDE lib/escape.4th

:MACRO S\" $1$ " ` S" ` >1> |#| >>> " |#| S>ESCAPE ;

  

S\" \tAnd the winner is:\t\q4tH compiler\q!"

Will expand to:

S" \tAnd the winner is:\t\q4tH compiler\q!" S>ESCAPE

18.2.4 The string stack

If four registers are not enough, there is also a string stack 
you can use to store strings. This macro will read a string and 
push it on the string stack:

:MACRO BEGIN-STRUCTURE @1@ >1> STRUCT ;

This macro will pop the string from the string stack and print 
it:

:MACRO END-STRUCTURE END-STRUCT <2< #2# ;

So if you write code like this:

BEGIN-STRUCTURE point

  FIELD: p.x

  FIELD: p.y

END-STRUCTURE

It will be expanded to this:

STRUCT

  FIELD: p.x

  FIELD: p.y

END-STRUCT point

If you're really short on registers, you can write a macro that 
saves the current value on the stack and restores it afterwards. 
Note that the string stack remains completely intact between 
calls. Just remember to keep it balanced at all times.

18.2.5 Phony variables

There are six phony variables >#>, <#<, >>>, $#$, _#_ and |#|. 
>#> works very much like @1@, @2@, etc. in that it parses a 
string. But instead of assigning it to a register, it is put on 
the string stack directly. <#< drops the top of the stack, so the 
sequence >#> <#< simply ignores a string:

:macro create @1@ @2@ >#> <#< >#> <#< #2# string #1# ;

create mystring 20 chars allot

>>> takes the next name or back quoted string and puts it on the 
string stack. So this will assign ”Hello world!” to the first 
register:

:macro hello >>> ` Hello world!` <1< ;

$#$ is much like the $1$ through $4$ commands, except it puts the 
parsed string on the string stack. Just like its cousins, it 
requires a delimiter. We could rewrite our implementation of ”S\"”
 as follows:

include lib/escape.4th

:macro S\" $#$ " ` S" ` |#| >>> " |#| s>escape ;

  

S\" \tAnd the winner is:\t\q4tH compiler\q!"

Then _#_, which simply prints the top of the stack. Finally |#|, 
which is used to concatenate strings. Normally before a string is 
printed a space or newline is added. |#| takes the top of the 
string stack and prints it as is. This way you can build macros 
like this, which prints a string constant:

:macro literal: @1@ ` S" ` >1> |#| >>> " |#| ;

literal: Hello

Needless to say that phony variables are only recognized within 
macros.

18.2.6 Branching and looping

The preprocessor also offers some simple branching and looping 
functionality. It may seem unusual and awkward at first, but it 
does the job. Basically, it exits the macro without discarding 
the flag when the comparison renders false, e.g.:

:macro ex1 >>> 0 @if ` This is never printed` ;

:macro example ` Print this` ex1 @drop ;

example

Will only print ”Print this”. @if will render true when the 
numerical equivalent of the string on the stack is non-zero. 
However, the flag - either zero or non-zero - will remain on the 
stack, so we have to drop it one nesting level lower by calling 
@drop, which is a synonym for <#<. We can also add an ”else” 
clause easily:

:macro ex1 >>> 0 @if ` This is never printed` ;

:macro ex2 ex1 @else ` But this is` ;

:macro example ` Print this` ex2 @drop ;

example

@else is the reverse of @if and exits the macro when the 
numerical equivalent of the string on the stack is non-zero, 
preserving and inverting the flag. The reason for the latter is, 
that you can always use @else for the alternate branch, no matter 
if you used @if, @ifnot, @while or @until.

@else is also known by another name @ifnot. Using @if and @else 
you can build an entire ”case” like construct:

:macro chars? >>> chars @while #2# string #1# ;

:macro cells? >>> cells @while #2# array  #1# ;

:macro (create)

  @1@ @2@ @3@ @4@

  >3> chars? @else @drop

  >3> cells? @else table #1# #2# #3# #4# ;

:macro create (create) @drop ;

This one in particular mimics the ANS-Forth 'CREATE' word, which 
is subsequently transformed into typical 4tH constructs, so you 
can compile code like this:

create mystring 20 chars allot

create myarray  40 cells allot

create mytable  5 , 6 , 7 ,

@while leaves a true flag on the stack when the top two strings 
are equal. Its counterpart is @until, which leaves a true flag on 
the stack when the top two strings are not equal. Using 
recursion, you can even build loops:

:macro line 

  @1@ >1> >>> %stop% @until @drop 

  ` ," ` >1> |#| >>> ` "` |#| @2@ #2# , line ;

:macro make @1@ table #1# line @drop ;

Note you'll have to drop the previous flag with each new 
iteration if you don't want to unbalance your string stack. It 
allows you to process code like this:

make bla

  terminate 5 negate  6

  virtual   7 endorse 9

%stop%

Which will result in a nice little table, ready to compile. Note 
all loops are based on recursion, so if you nest too deep you may 
run out of stack space, which will result in an internal error.

18.2.7 Functions

There are several functions you can use within a macro. @add, for 
example, will add the two topmost entries on the string stack and 
leave the result. You can easily create counted loops with @add:

:macro hello @if Hello! >>> -1 @add hello ;

:macro hello's >#> hello @drop ;

So this will print ”Hello!” ten times:

hello's 10

It is even powerful enough to resolve a CASE..ENDCASE construct:

:macro case >>> 0 ;

:macro of over = if drop ;

:macro endof else >>> 1 @add ;

:macro endif @if then >>> -1 @add endif ;

:macro endcase drop endif @drop ;

  

: .WEEKDAY ( daynum --- )

  CASE

      1 OF ." Sunday"    ENDOF

      2 OF ." Monday"    ENDOF

      3 OF ." Tuesday"   ENDOF

      4 OF ." Wednesday" ENDOF

      5 OF ." Thursday"  ENDOF

      6 OF ." Friday"    ENDOF

      7 OF ." Saturday"  ENDOF

  ENDCASE ;

With @minus you can negate a number on the stack, so subtractions 
are possible too. Multiplications can also be performed by using 
@mul. Divisions are supported by the @divrm function, which 
leaves the division and modulo on the stack. If you want to 
evaluate the result of an arithmetic expression, you can use 
@sign. @sign returns -1 when the top of the string stack is 
negative, 1 when it is positive and else zero. It closely 
resembles the [SIGN] directive of 4tH.

@cell will leave a true flag on the stack if the top of the stack 
can be converted to a number. Some stack instructions are 
provided as well, like @drop, @dup, @nip and @over. They work 
exactly like their 4tH counterparts. @cr simply issues a newline.

The most elusive function may be @eval. If the top of the string 
stack contains the name of a user-defined macro, it will be 
executed. If it doesn't, the top of the stack is simply printed. 
You can use this function to interpret a string of user-defined 
macro's or simply print the top of the stack.

You can check the existence of a user-defined macro with @exist, 
which leaves a non-zero value if the top of the string stack is 
the name of a user-defined macro. Finally, @match will compare 
the two topmost items on the string stack and leave a zero value 
if they match.

18.3 Invocation (script)

Since the preprocessor is written in 4tH, you can invoke it in 
the usual way:

4th cxq pp4th.4th mysource.4pp mysource.4th

You can also use make, see section [sec:Using-the-library]. Note 
the preprocessor uses the DIR4TH environment variable to locate 
include files.

18.3.1 Options

The preprocessor supports the following options:

-D symbol Define symbol as a CONSTANT, with value 1. You may add 
as many -D options as you require.

-D symbol=value Define symbol as a CONSTANT, with value value. 
You may add as many -D options as you require.

-v Enter verbose mode and show all files included hierarchically.

18.4 Invocation (executable)

The preprocessor is also embedded in a executable, so you can 
execute, decompile or save the generated file right away. It 
recognizes .4pp files and preprocesses them automatically. All 
other files are automatically compiled.

When a file is preprocessed a temporary file is created in your 
working directory. Unless you specifically indicate this 
temporary file should be kept, it is deleted. The name of this 
temporary file is equal to the preprocessor file, but with a .4pi 
extension.

This version of the preprocessor honors the DIR4TH environment 
variable completely. Parameters following the input filename are 
passed to the compiled program when executing.

18.4.1 Options

The preprocessor supports the following options:

-D symbol Define symbol as a CONSTANT, with value 1. You may add 
as many -D options as you require.

-D symbol=value Define symbol as a CONSTANT, with value value. 
You may add as many -D options as you require.

-o filename Specify the name of the output file when 
preprocessing, generating or saving.

-i Show all files included hierarchically.

-c Load a sourcefile and compile it.

-p Preprocess a 4tH preprocessor file.

-d Decompile a 4tH program.

-g Generate a C sourcefile (default: out.c).

-s Save a 4tH program (default: out.hx).

-x Execute a 4tH program.

-v Enter verbose mode.

-V Show version and exit.

18.5 Preprocessor commands

\ s The remainder of the line s is discarded. Used for comment.

( s) Discard comment s that is delimited by a right parenthesis. 
A blank after the leading parenthesis is required.

char c Replaces character c as with its ASCII value.

[char] c Replaces character c as with its ASCII value.

include s The contents of file s, delimited by whitespace, are 
inserted at this position.

[needs s] The contents of file s, delimited by a right bracket, 
are inserted at this position.

:macro s ; Create a macro with the name s, delimited by a 
semi-colon. When s is encountered it is replaced by the contents 
of the macro. A macro may contain any sequence of valid 4tH 
words, including conditional and loop statements, but no macros 
or include files.

scrap: s Delete a macro with the name s. After that, s will not 
be expanded anymore and name s can be used to define a new macro. 
Note that the macro space allocated by s is not freed.

[binary] Sets radix to binary.

[octal] Sets radix to octal.

[decimal] Sets radix to decimal.

[hex] Sets radix to hexadecimal.

18.6 Error messages

Usage: pp4th infile outfile Issue a preprocessor file and a 
source file on the commandline

Macro space exhausted The combined size of all macro definitions 
is too large

Unexpected macro The preprocessor found a :MACRO word within a 
previously started macro definition

Too many macros There are too many macro definitions in the 
currently processed file

Duplicate macro A macro with this name is already defined

Undefined macro A SCRAP: directive was followed by an undefined 
macro name

Directive not allowed here You cannot use an INCLUDE, [NEEDS or 
SCRAP: directive within a macro

Unexpected end of file A number, character, string, name or other 
expression was expected in the currently processed file

String too long The string parsed was too long to be stored in a 
variable

Missing string A $1$, $2$, $3$, $4$, $#$ or >>> variable was not 
followed by a string

Bad number The top of the string stack is not a valid number

String stack empty There were no strings left on the string stack

String stack full There were too many strings stored on the 
string stack

String stack not empty There were still items on the string stack 
after processing the current file

Seek failed The preprocessor was unable to restore the file 
status after processing an include file

Cannot open <file> Could not find a preprocessor file

Include file nested too deep Too many include files included 
within other include files

Cannot open include file Could not find an include file

Cannot read include file Could not read the include file

Internal error An internal condition caused the preprocessor to 
stop, e.g. stack overflow

18.7 <sec:Bugs-and-limitations>Known bugs and limitations

• Some programs use conditional compilation to accommodate large 
  comments. The preprocessor can only assume such sections 
  contain compilable code and will treat it as such. If these 
  comments contain words that are identical to macro names or 
  preprocessor commands the appropriate substitutions will be 
  made, which may in some circumstances raise errors.

• Some programs will span ( comments across several lines. 
  Although 4tH will accept such comments, it is a violation of 
  the ANS-Forth standard. The preprocessor does not support such 
  usage.

• Character literals are expanded under the current radix, so 
  take care when using them in a macro.

• Back quoted strings offer no protection against macro 
  expansion. If a back quoted string is recognized as a macro 
  name, add a leading or trailing space.

• Although macro definitions may be nested, extreme nesting of 
  macros is known to trigger internal errors.

• A runaway recursion may trigger internal or end-of-file errors.

• Severe violations of the ANS-Forth standard may trigger erratic 
  behavior.

18.8 Preprocessor libraries

This table list all libraries, the user words they provide, their 
field of application and the registers they use. It is not 
recommended to use any internal words defined in the library nor 
to define any words starting with an underscore. Some libraries 
contain words that are intended to be used inside other macros, 
others provide new keywords you can use in your programs. Note 
that not all libraries can be combined. Refer to the source for 
details.

Some libraries clobber one or more registers. If any of these 
registers contain meaningful values when you use the library, 
these values will be overwritten. Save them on the stack before 
using any of these words or refrain from using these registers 
yourself.






+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| Library       | Provides                                                                                                                                                                                                                    | Application  |    Registers Used    |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| closures.4pp  | :: vars end-vars var: this { } set sizeof {: ;}                                                                                                                                                                             |   Program    |          --          |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| ansforth.4pp  | action-of synonym begin-structure end-structure case of endof 
endcase                                                                                                                                                      |   Program    |          --          |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| comus.4pp     | +to                                                                                                                                                                                                                         |   Program    |          --          |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| double.4pp    | d% 2variable 2constant                                                                                                                                                                                                      |   Program    |          --          |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| float.4pp     | f% fvariable ffield: fconstant                                                                                                                                                                                              |   Program    |          --          |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| foos.4pp      | derived? :: type@ typeof parent@ kindof parentof sizeof class 
extends end-class virtual: method: end-extends { } this {} 
:virtual :default :method => virtual ;method <- default static 
new instance private{ overrides  |   Program    |          --          |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| rangext.4pp   | le ge lt gt                                                                                                                                                                                                                 |   Program    |          --          |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| ifdef.4pp     | @ifdef @ifndef @then                                                                                                                                                                                                        |   Program    |          --          |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| sbslquot.4pp  | s\"                                                                                                                                                                                                                         |   Program    |          --          |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| yield.4pp     | yield grab                                                                                                                                                                                                                  |   Program    |          --          |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| interprt.4pp  | [ ]                                                                                                                                                                                                                         |    Macro     |          --          |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+
| standard.4pp  | @swap @rot @max @min @abs                                                                                                                                                                                                   |    Macro     | @swap: 1; @rot: 1, 2 |
+---------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------+


uBasic manual

19.1 Introduction

uBasic is an integer Basic interpreter in the tradition of Tiny 
Basic, with which it is largely compatible. It is derived from a 
program made by Herbert Schildt in the late eighties and 
published in his book ”C: The complete reference”. This version 
is entirely written in 4tH, some bugs have been removed and 
several additional features have been added. In order to execute 
a program you can invoke it in the usual way:

4th cxq ubasic.4th lander.bas

Of course, you may opt to create an executable or script suited 
for your operating system.

19.2 Statements

• Labels are numeric, so 0020 refers to the same label as 20;

• Labels are optional unless there is a GOSUB or GOTO statement 
  referring to them;

• Precedence, from high to low: (, ), unary -, ^, *, / , %, +, -, 
  #, =, <, >;

• A compound statement may consist of a single statement;

• Whitespace is ignored;

• uBasic is not case sensitive.


+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Concept             | Definition                                                                                                                          | Abbreviation |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Label               | Any positive integer                                                                                                                |      a       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Number              | Any signed integer                                                                                                                  |      n       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Function            | ABS(), RND(), TOS(), POP()                                                                                                          |      f       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Variable            | A to Z                                                                                                                              |      v       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Primitive           | Any variable, function or number                                                                                                    |      p       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Operator            | #, =, <, >, *, /, +, - or %                                                                                                         |      o       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Term                | (p o p)                                                                                                                             |      t       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Expression          | (t o t)                                                                                                                             |      e       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Array element       | @ ( e )                                                                                                                             |      v       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| String              | Any combination of ASCII-7 characters                                                                                               |      s       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Quoted string       | Any combination of ASCII-7 characters (except a double quote) 
between double quotes                                                |      q       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Keyword             | IF, PRINT, REM, GOTO, GOSUB, FOR, NEXT, LET, INPUT, RETURN, END, 
STOP, PUSH, CONTINUE, BREAK, DO, LOOP, UNTIL, WHILE, ELSE, ENDIF  |      k       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Statement           | Correct use of a keyword                                                                                                            |      st      |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Compound statement  | st : st : st                                                                                                                        |      c       |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+
| Line                | a c                                                                                                                                 |      ln      |
+---------------------+-------------------------------------------------------------------------------------------------------------------------------------+--------------+


LET v = e This statement assigns the value of the expression to 
the variable. The keyword LET is optional. 

GOTO e The GOTO statement permits changes in the sequence of 
program execution. Normally programs are executed in the 
numerical sequence of the program line numbers, but the next 
statement to be executed after a GOTO has the line number derived 
by the evaluation of the expression in the GOTO statement. Note 
that this permits you to compute the line number of the next 
statement on the basis of program parameters during program 
execution. An error stop occurs if the evaluation of the 
expression results in a number for which there is no line.

GOSUB e The GOSUB statement is like the GOTO statement, except 
that uBasic remembers the line number of the GOSUB statement, so 
that the next occurrence of a RETURN statement will result in 
execution proceeding from the statement following the GOSUB. 
Subroutines called by GOSUB statements may be nested up to a 
predefined depth. 

RETURN The RETURN statement transfers execution control to the 
line following the most recent unRETURNed GOSUB. If there is no 
matching GOSUB an error stop occurs.

IF e THEN c The IF statement evaluates an expression. If the 
expression renders non-zero, the entire compound statement is 
executed; if zero, the associated compound statement is skipped. 
The keyword THEN is optional. If an IF statement does not contain 
a compound statement, multiple line syntax is assumed, requiring 
the use of the ENDIF keyword. A multiple line syntax block may 
not contain a single line syntax statement.

ELSE Will execute all statements following it until the keyword 
ENDIF is encountered, if the expression of the corresponding IF 
statement renders zero. Assumes multiple line syntax. The ELSE 
clause is optional. 

ENDIF Terminates an IF statement in multiple line syntax.

END The END statement must be the last executable statement in a 
program. The END statement may be used to terminate a program at 
any time, and there may be as many END statements in a program as 
needed. 

REM s The REM statement permits comments to be interspersed in 
the program. Its execution has no effect on program operation, 
except for the time taken.

PUSH e[, e] Evaluates one or more expressions, separated by 
commas, and puts the results on the stack. The rightmost 
expression is top of stack.

PRINT q|e ,|; This statement prints the values of the expressions 
and/or the contents of the quoted strings. Expressions are 
evaluated and printed as signed numbers; strings are printed as 
they occur in the PRINT statement, except for the escape 
characters listed in table [tab:Supported-control-characters]. 
When the items are separated by commas the printed values are 
justified in columns of 8 characters wide; when semicolons are 
used there is no separation between the printed items. Thus, 
PRINT 1,2,3 prints as 1 2 3 and PRINT 1;2;3 prints as 123. Commas 
and semicolons, strings and expressions may be mixed in one PRINT 
statement at will. If a PRINT statement ends with a comma or 
semicolon, uBasic will not terminate the output line so that 
several PRINT statements may print on the same output line, or an 
output message may be printed on the same line as an input 
request (see INPUT). When the PRINT statement does not end with a 
comma or semicolon the line is terminated.

INPUT q ,|; v The quoted string is printed. If the quoted string 
is omitted, a question mark is prompted. A new line is read in 
and the input line is scanned for a number. The value thus 
derived is stored in the variable.

FOR v = e TO e STEP e Sets up a control variable with an initial 
value (first expression), an optional limit (second expression), 
an optional increment (third expression) and a looping address 
referring to the statement after the FOR statement. If STEP is 
omitted an increment of 1 is assumed. If TO and STEP are omitted, 
an infinite loop is assumed. If the initial value is greater than 
the limit, execution will continue after the matching NEXT. See 
NEXT.

NEXT v Increments the control variable and then jumps to the 
matching FOR statement. The variable is optional. Every FOR 
statement must be matched by one single NEXT statement. Poor 
programming style, such as the use of GOTO to exit loops or 
conditional NEXT statements, may leave unused frames on the FOR 
stack.

DO A control structure to repeat a set of statements an 
indefinite number of times, usually WHILE or UNTIL a condition is 
satisfied. See LOOP.

LOOP Every DO statement must be matched by one single LOOP 
statement. Poor programming style, such as the use of GOTO to 
exit loops or conditional LOOP statements, may leave unused 
frames on the FOR stack.

CONTINUE Resumes iteration of the matching FOR loop, incrementing 
the corresponding control variable where appropriate. 

BREAK Terminates the matching FOR loop unconditionally.

WHILE e Terminates the matching FOR or DO loop by calling BREAK 
if the expression renders zero.

UNTIL e Terminates the matching FOR or DO loop by calling BREAK 
if the expression renders non-zero.

19.3 Functions

RND(e) Returns a random number between 0 and the value of the 
expression. Thus, B=RND(3) assigns either 0, 1 or 2 to B.

ABS(e) Returns the absolute value of the expression.

TOS() Returns the top of the stack.

POP() Takes the top from the stack and returns its value.

19.4 Error messages

An error message takes the form of:

A message, B:C

Where A is the error code, B is the line number where the error 
occurred and C the position within that line (excluding the label 
itself). The latter points to the last character of the token 
which caused the error.






+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| Code  | Message                              | Description                                                                                                                                   |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  0    | OK                                   | Program terminated succesfully.                                                                                                               |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  1    | NEXT, CONTINUE or BREAK without FOR  | There was one more NEXT than there were FORs. BREAK or CONTINUE 
were used outside a FOR loop (FOR stack underflow).                          |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  2    | Assignment expected                  | A '=' character was expected. May be a superfluous variable.                                                                                  |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  3    | Too many labels                      | Too many labels were defined, decrease the number of labels.                                                                                  |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  4    | Duplicate label                      | A label was defined twice.                                                                                                                    |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  5    | Undefined label                      | A jump or call to an undefined label was attempted.                                                                                           |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  6    | Number too big                       | The number didn't fit in a signed integer.                                                                                                    |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  7    | RETURN without GOSUB                 | There has been one more RETURN than there were GOSUBs (GOSUB 
stack underflow).                                                               |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  8    | Too many nested FOR loops            | Too many FOR statements were embedded in other FOR statements 
(FOR stack overflow).                                                          |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  9    | Too many nested GOSUBs               | Too many GOSUBs were called (GOSUB stack overflow).                                                                                           |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  A    | ENDIF or NEXT expected               | A FOR or IF statement was not properly terminated by NEXT or 
ENDIF.                                                                          |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  B    | Unbalanced delimiters                | A closing parenthesis or double quote was expected.                                                                                           |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  C    | Nonsense in BASIC                    | A statement or expression was not composed correctly.                                                                                         |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  D    | Expression expected                  | An expression was expected.                                                                                                                   |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  E    | Not a variable                       | The variable name did not consist of a single, alphabetic 
character or array element. The subscript of the array element 
was out of bounds. |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  F    | Not a function                       | The function is unknown or misspelled.                                                                                                        |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  G    | Stack empty                          | Too many POP()s were issued (data stack overflow)                                                                                             |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
|  H    | Stack full                           | Too many PUSHs were issued (data stack overflow)                                                                                              |
+-------+--------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+


19.4.1 System messages

System failure An internal condition caused the interpreter to 
stop, e.g. division by zero.

File loading error The source file could not be opened.

Out of memory The source file was bigger than available memory.

ANS Forth statement

Forth, like BASIC, has always suffered from a lack - or may be an 
abundance of standards. Both languages had many dialects, which 
were highly incompatible. However, although there was never a 
generally accepted BASIC standard, a simple BASIC program can be 
easily converted to almost any existing implementation of the 
language.

The Forth community had a different approach to the problem. They 
kept changing the core every few years, so even now it's very 
hard to find a program which can run on any Forth with little 
modification. Calling those very different versions a standard 
didn't really help.

So when the ANSI-standard committee began its work they had a few 
very though nuts to crack. In our view the ANS-Forth standard is 
big step forward, but not perfect. It has not fully regained the 
simplicity we found in the Forth-79 and still has some serious 
flaws, although most are an inheritance from Forth-83.

We do feel the need for a real Forth standard, so we tried to 
make 4tH as ANS-Forth compatible as possible without sacrificing 
the ease of use that we had in mind when we designed it. About 
95% of the CORE wordset is supported.

4tH was built according to the ANS-Forth standard, but with a 
tiny Forth-79 flavor. Full compliance to the ANS-Forth standard 
was never an objective. According to the ANS-Forth standard 4tH 
cannot be an "ANS-Forth System", since the standard does not 
cover this kind of implementation.

20.1 ANS-Forth Label

According to the ANS-Forth standard, section 5.2.2, this system 
is capable of compiling:

ANS Forth Programs

Requiring:

• the Block word set

• the Exception word set

• the Memory word set

• the String Extensions word set

Requiring selected words from:

• the Core Extensions word set

• the Block Extensions word set

• the Double number word set

• the Double number Extensions word set

• the Facility Extensions word set

• the File-Access word set

• the File-Access Extensions word set

• the Floating-Point word set

• the Floating-Point Extensions word set

• the Programming-Tools word set

• the Programming-Tools Extensions word set

• the String word set

• the XCHAR wordset

• the XCHAR Extensions word set.

End of label. Although the ANS-Forth standard (section 4.1) 
requires documentation to be presented in a prescribed format, 
4tH does not comply for the simple reason that due to its 
architecture it is not considered to be a "ANS Forth System" 
(sections 3.3, 3.4, 5.1).

Note that due to this special architecture some words are missing 
from the CORE wordset or behave slightly different, so some "ANS 
Forth Programs" with the requirements mentioned above may not 
compile or compile only with modifications.

20.2 Unsupported CORE words

These words are not available in 4tH. Some CORE words are only 
available in source (ANS-Forth, section 3). You can find them in 
the 4tH glossary. The behaviour of some 4tH words may differ from 
the ANS-Forth definition.

ALLOT

FIND

LITERAL

POSTPONE

STATE

[

]

20.3 Supported ANS Forth word sets

The words in the following sections are supported by 4tH; 
external words are in italics, preprocessor words are underlined. 
Please note that due to 4tHs special architecture some words may 
behave slightly different, so some "ANS Forth Programs" using 
these words may need modifications in order to run properly. More 
words are available in source and can be loaded when required.

20.3.1 Core Extensions word set

#TIB

.(

.R

0<>

0>

2>R

2R>

2R@

:NONAME

<>

?DO

ACTION-OF

AGAIN

CASE

ENDCASE

ENDOF

ERASE

EXPECT

FALSE

HEX

HOLDS

OF

NIP

PAD

PARSE

PARSE-NAME

PICK

QUERY

REFILL

RESTORE-INPUT

ROLL

S\"

SAVE-INPUT

SOURCE-ID

TIB

TO

TRUE

TUCK

U.R

U>

VALUE

WITHIN

\

20.3.2 Block Extensions word set

EMPTY-BUFFERS

LIST

SCR

20.3.3 Double number word set

2CONSTANT

2VARIABLE

D+

D-

D.

D.R

D0<

D0=

D2*

D2/

D<

D=

D>S

DABS

DMAX

DMIN

DNEGATE

M+

M*/

20.3.4 Double number Extensions word set

2ROT

DU<

20.3.5 Facility Extensions word set

+FIELD

BEGIN-STRUCTURE

CFIELD:

END-STRUCTURE

FIELD:

KEY?

MS

TIME&DATE

20.3.6 File-Access word set

(

BIN

CLOSE-FILE

CREATE-FILE

DELETE-FILE

FILE-POSITION

FILE-SIZE

OPEN-FILE

R/O

R/W

READ-FILE

READ-LINE

REPOSITION-FILE

S"

SOURCE-ID

W/O

WRITE-FILE

WRITE-LINE

20.3.7 File-Access Extensions word set

FILE-STATUS

FLUSH-FILE

REFILL

RENAME-FILE

20.3.8 Floating-Point word set

>FLOAT

D>F

F!

F*

F+

F-

F0<

F0=

F<

F>D

F@

FALIGN

FALIGNED

FCONSTANT

FDEPTH

FDROP

FDUP

FLOAT+

FLOATS

FLOOR

FMAX

FMIN

FNEGATE

FOVER

FROT

FROUND

FSWAP

FVARIABLE

REPRESENT

20.3.9 Floating-Point Extensions word set

F**

F.

F>S

FABS

FACOS

FACOSH

FALOG

FASIN

FASINH

FATAN

FATAN2

FATANH

FCOS

FCOSH

FE.

FEXP

FEXPM1

FFIELD:

FLN

FLNP1

FLOG

FS.

FSIN

FSINCOS

FSINH

FSQRT

FTAN

FTANH

F~

PRECISION

S>F

SET-PRECISION

20.3.10 Programming-Tools word set

.S

?

DUMP

20.3.11 Programming-Tools Extensions word set

N>R

NR>

SYNONYM

[ELSE]

[IF]

[THEN]

20.3.12 String word set

-TRAILING

/STRING

BLANK

CMOVE

CMOVE>

COMPARE

SEARCH

20.3.13 XCHAR word set

X-SIZE

XC-SIZE

XC@+ 

XC!+

XC!+?

XCHAR+

XEMIT

20.3.14 XCHAR Extensions word set

-TRAILING-GARBAGE

X-WIDTH

XHOLD

XC-WIDTH

+X/STRING 

X\STRING-

XCHAR-

Porting guide

21.1 Introduction

4tH is ANS-Forth compatible. That means that 4tH and ANS-Forth 
share a common wordset, so you can write programs that run on 
both systems. This guide will show you how you can write portable 
programs or convert eligible ANS-Forth programs to 4tH with as 
little effort as possible.

21.2 General guidelines

We have already stated that 4tH and ANS-Forth have much in 
common, but it is unlikely that you can write a non-trivial 
program that runs unmodified on both platforms without resorting 
to conditional compilation, which allows you to "hide" 
implementation specific code. The word '4TH#' not only holds 
4tH's version number, but is also an effective way to 
differentiate between 4tH and other compilers:

[DEFINED] 4TH# [IF] 

variable span 

: expect 1- accept span ! ; 

[THEN]

Of course, the opposite works too:

[UNDEFINED] 4TH# [IF] 

s" easy.4th" included

[THEN]

If you have an interactive program you might want to disable the 
4tH autostart:

[DEFINED] 4TH# [IF] start-program [THEN]

Otherwise 'REFILL' will try to get its input from the file 
instead of the keyboard.

21.3 Differences between 4tH and ANS-Forth

Like any software, 4tH is a compromise. We have to address the 
requirements of both newbies and power users, which means we have 
to make choices[footnote:
You may or may not agree with the choices we made, but you can 
rest assured we have given them considerable thought.
] concerning ANS-Forth compliancy. There are several reasons why 
4tH is not completely ANS-Forth compliant:

1. 4tH uses a different architecture which makes it impossible to 
  be ANS-Forth compliant, so some constructions are simply not 
  feasible;

2. Some constructions in ANS-Forth are considered to be 
  illogical, unelegant, bloated, not intuitive, error prone, 
  inefficient or otherwise not acceptable;

3. 4tH maintains a close relationship with C, so it is more 
  logical and efficient to use C-conventions instead of ANS-Forth 
  conventions.

Where possible, we try to minimize the consequences for our users 
by hiding the differences behind abstractions or other 
transparent solutions. But sometimes, we simply can't. In this 
section we will show you which differences there are between 4tH 
and ANS-Forth and how you can either avoid or resolve them.

21.3.1 Strings

In 4tH, strings are stored in an ASCIIZ format. ANS-Forth uses 
counted strings. In 4tH there is no such thing as a countbyte, 
since it uses a terminator. If you limit the use of 'COUNT' only 
to string variables and constants, and exclusively use 'PLACE' or 
'+PLACE' you should be fine, since the address/count convention 
of ANS-Forth is fully supported. Should you resort to low level 
operations which require a terminator, you might have to define 
an equivalent word in ANS-Forth to make your program portable.

'S"' does have interpretation semantics, but the string stored at 
the address 'S"' returns might have a very short lifespan, 
depending on your ANS-Forth compiler. 4tH has a transparent, 
circular buffer that protects the string from overwriting, but 
when you port your program you might not be that lucky. Note that 
ANS-Forth does not require compilers to provide these facilities.

21.3.2 Double numbers

4tH uses only signed 32 bit cells, but some words in ANS-Forth, 
like '<#', '#>', 'FILE-SIZE', 'FILE-POSITION' and 
'REPOSITION-FILE' require the use of double numbers. You can 
easily fix this by adding 'S>D', which converts a number to a 
double number. Its counterpart, 'D>S', is available too. In 4tH 
these words have no effect.

21.3.3 Booleans

Another nice topic for a flame war is the value of truth. In 
ANS-Forth the 'TRUE' has the value "-1", which means all bits are 
set. Which is very clever. You can 'XOR', 'OR', 'AND' and 
'INVERT' it with any other value and it will behave as logical 
value. But "the all bits set" flag has its drawbacks too. Let's 
see what the ANS-Forth standard says about flags:

"A FALSE flag is a single-cell datum with all bits unset, and a 
TRUE flag is a single-cell datum with all bits set. While Forth 
words which test flags accept any non-null bit pattern as true, 
there exists the concept of the well-formed flag. If an operation 
whose result is to be used as a flag may produce any bit-mask 
other than TRUE or FALSE, the recommended discipline is to 
convert the result to a well-formed flag by means of the Forth 
word 0<> so that the result of any subsequent logical operations 
on the flag will be predictable. In addition to the words which 
move, fetch and store single-cell items, the following words are 
valid for operations on one or more flag data residing on the 
data stack: AND OR XOR INVERT"

We highly recommend the discipline of converting a non-zero value 
to a well-formed flag. But we don't understand why 'INVERT' is a 
valid way to manipulate a flag. We'll try to explain you why.

Forth traditionally has no specific logical operators. Instead, 
binary operators were used. This put 'INVERT' (or 'NOT' as it was 
called in Forth-79) in a difficult position. 'INVERT'ing any 
non-zero value will result in a non-zero value, except when all 
bits are set.

That is why '0=' was introduced, a full-fledged logical operator. 
So why use 'INVERT' when you want to perform a logical operation? 
Another quote:

"Since a "char" can store small positive numbers and since the 
character data type is a sub-range of the unsigned integer data 
type, C! must store the n least-significant bits of a cell (8 <= 
n <= bits/cell). Given the enumeration of allowed number 
representations and their known encodings, "TRUE xx C! xx C@" 
must leave a stack item with some number of bits set, which will 
thus will be accepted as non-zero by IF."

This is another problem of using "all bits set" as a true flag: 
you store a well formed flag in an address unit that should 
easily be able to handle it and you'll never get it back. A flag 
is a boolean and can have two values: either true or false. The 
smallest unit that can hold a boolean is a bit. ANS-Forth 
programmers are denied that privilege.

But why are some Forth programmers so keen on their “all bits set”
 flag? Well, you can do neat things with it.

: >CHAR DUP 9 > 7 AND + ASCII 0 + ;

This will convert a digit to its ASCII representation. True, it 
is a clever piece of programming, but in our opinion it is bad 
style. Why? Because you are using a flag as a bitmask, which is a 
completely different datatype. Although there is no such thing as 
“data typing” in Forth, this way of programming makes it 
difficult to understand and maintain a program, which the 
ANS-Forth standard acknowledges:

"The discipline of circumscribing meaning which a program may 
assign to various combinations of bit patterns is sometimes 
called data typing. Many computer languages impose explicit data 
typing and have compilers that prevent ill-defined operations. 
Forth rarely explicitly imposes data-type restrictions. Still, 
data types implicitly do exist, and discipline is required, 
particularly if portability of programs is a goal. In Forth, it 
is incumbent upon the programmer (rather than the compiler) to 
determine that data are accurately typed."

That is why 4tH uses "1" as a true flag. Usually, it won't make 
much difference. Except when you use 'INVERT' to invert a flag or 
intend to make obfuscated programs. If you use '0=' instead, you 
won't run in any trouble, not even when you port your program to 
ANS-Forth. Clarity may introduce a little overhead, but in this 
age of multi-gigaherz machines, who is counting? E.g. you could 
program “>CHAR” like this:

                                          \ convert a flag to a 
bit mask 

: >MASK 0 SWAP IF INVERT THEN ;           ( f -- mask)

                                          \ convert a digit to 
ASCII

: >CHAR DUP 9 > >MASK 7 AND + ASCII 0 + ; ( n -- c)

If you still want to change the true flag, you can by simply 
changing a #define in cmds_4th.h:

#define F_T ~(0L)

But we doubt whether it will be a great benefit to your 
programming style.

21.3.4 CREATE..DOES><sub:CREATE..DOES>>

In both 4tH and ANS-Forth it is possible to change the runtime 
behavior of variables. E.g. in ANS-Forth, 'CONSTANT' is usually 
defined as:

: CONSTANT CREATE , DOES> @ ; 

10 CONSTANT MY_CONST 

MY_CONST . CR

Of course there is a predefined word in 4tH that does this, but 
if you wanted to mimic this behavior you would have to define it 
like this:

CREATE MY_CONST 10 , DOES> @C ;           \ Definition of 
CONSTANT

MY_CONST . CR                             \ Works the same way

The point is that the ANS-Forth "CREATE DOES>" construct cannot 
be ported to 4tH, although all words seem to be supported. A rule 
of the thumb is that defining words cannot be used to define new 
defining words, like in ANS-Forth. Most errors will be trapped by 
4tH's compiler, though[footnote:
Note that the use of 'DOES>' in 4tH is called ”interpretation” in 
ANS-Forth, which is explicitly forbidden. Some Forth compilers 
(like gForth) have defined the interpretation semantics of 
'DOES>' and are consequently largely compatible with 4tH's 
'DOES>'.
].

Just remember that a ':REDO' definition can easily be ported to 
ANS-Forth. If you want to write a portable program, ':REDO' is 
the way to do it.

21.3.5 HERE

Be careful with 'HERE'. 'HERE' looks and acts a lot like the 
ANS-Forth 'HERE', but since the architecture is different it 
serves quite another function. When 'HERE' is used for address 
arithmetic with definitions or arrays of constants, it works 
right out of the box. If not, it usually doesn't.

21.3.6 2>R and 2R>

These words are included in order to let you put two items on the 
Return Stack at once, fetch them using '2R@' and return them on 
the Data Stack safely. However, ANS-Forth assumes a certain order 
of these two items, so they can be fetched separately by 'R@' and 
'R>'. 4tH does not support this specific order. A safe way to 
emulate the ANS-Forth behavior is to swap the values before you 
put them on the stack and swap them again when they are 
retrieved, e.g.:

2R> DO

  I over -  3 .R

  over I = IF ." *" ELSE SPACE THEN

  I 2 +  7 MOD 0= IF  CR  THEN

LOOP 2DROP ;

Becomes:

R> R> SWAP DO

  I over -  3 .R

  over I = IF ." *" ELSE SPACE THEN

  I 2 +  7 MOD 0= IF  CR  THEN

LOOP 2DROP ;

Note that the latter is ANS-Forth compliant.

21.3.7 Interpretation and compilation mode

There are several words, which act differently in interpretation 
and compilation mode. In Forth-79, some of them were 
"state-smart", which means they adjusted their behavior depending 
on the mode the system was in. In Forth-83 and subsequently 
ANS-Forth, they became "dumb" words and counterparts were 
designed for each mode. Other words lacked interpretation 
semantics all together.

4tH has got neither a true interpretation mode nor a state. But 
if you want to port 4tH code to ANS-Forth, this has to be dealt 
with. In 4tH this porting issue is resolved by several aliases. 
Some words have an alias since they do not have interpretation 
semantics in the ANS-Forth standard, but are often used outside 
colon-definitons in 4tH. This will enable you to make a word that 
mimics these interpretation semantics.

This table lists all "dumb" words with their counterparts. 
"Interpretation" means it has to be used outside 
colon-definitions. "Compilation" means it has to be used inside 
colon-definitions.

[float Table:

+-----------------+-------------+
| Interpretation  | Compilation |
+-----------------+-------------+
| '               | [']         |
+-----------------+-------------+
| .(              | ."          |
+-----------------+-------------+
| CHAR            | [CHAR]      |
+-----------------+-------------+


[Senseless!!! 
Dumb words
]
]

Finally, in ANS-Forth all flowcontrol words (like IF, THEN, 
BEGIN, WHILE, DO, LOOP) may only be used inside 
colon-definitions.

21.3.8 BEGIN..WHILE..REPEAT

4tH allows you to use multiple WHILE's in a BEGIN..WHILE..REPEAT 
construct. ANS-Forth allows that too, but requires an extra 
'THEN' for each additional 'WHILE'. In short, this is the 4tH 
version:

0 begin dup 10 < while 1+ dup 5 mod while 1+ repeat

And this is the ANS-Forth version:

0 begin dup 10 < while 1+ dup 5 mod while 1+ repeat then

To make this work, we have to resort to conditional compilation:

0 begin dup 10 < while 1+ dup 5 mod while 1+ repeat

[undefined] 4th# [if] then [then]

It's not beautiful, but it works. The same applies when 'UNTIL' 
is used instead of 'REPEAT'. BEGIN..WHILE..AGAIN constructs are 
not supported by ANS-Forth, so be careful when considering 
'AGAIN' too much of an alias of 'REPEAT'. Also bear in mind that 
DONE..DONE clauses can be defined in ANS-Forth, but still require 
conditional compilation if you resort to multiple 'WHILE's.

21.3.9 CASE..OF..ENDOF..ENDCASE

Many users wonder why this ”essential” construct is missing in 
4tH. The explanation is pretty simple: it is horrible! First, 
this construct puts a heavy burden on the controlstack, which is 
pretty shallow in 4tH. Why? Because it is essentially a nested 
IF..ELSE..THEN construct as you will see later on. Second, these 
kinds of problems are better handled by a lookup table. 4tH has 
excellent support for lookup tables, much better than other 
Forths.

Of course, sometimes you just want to convert a program and don't 
feel like redesigning it. Fortunately, converting 
CASE..OF..ENDOF..ENDCASE constructs is pretty straightforward. It 
only requires four simple steps. Let's examine this simple 
example:

: .WEEKDAY ( daynum --- )

  CASE

      1 OF ." Sunday" ENDOF

      2 OF ." Monday" ENDOF

      3 OF ." Tuesday" ENDOF

      4 OF ." Wednesday" ENDOF

      5 OF ." Thursday" ENDOF

      6 OF ." Friday" ENDOF

      7 OF ." Saturday" ENDOF

  ENDCASE ;

  Step 1: Replace ENDOF with ELSE and eliminate CASE

: .WEEKDAY ( daynum --- )

      1 OF ." Sunday" ELSE

      2 OF ." Monday" ELSE

      3 OF ." Tuesday" ELSE

      4 OF ." Wednesday" ELSE

      5 OF ." Thursday" ELSE

      6 OF ." Friday" ELSE

      7 OF ." Saturday" ELSE

  ENDCASE ;

  Step 2: Replace OF with OVER = IF DROP

: .WEEKDAY ( daynum --- )

      1 OVER = IF DROP ." Sunday" ELSE

      2 OVER = IF DROP ." Monday" ELSE

      3 OVER = IF DROP ." Tuesday" ELSE

      4 OVER = IF DROP ." Wednesday" ELSE

      5 OVER = IF DROP ." Thursday" ELSE

      6 OVER = IF DROP ." Friday" ELSE

      7 OVER = IF DROP ." Saturday" ELSE

  ENDCASE ;

  Step 3: Replace ENDCASE with DROP

: .WEEKDAY ( daynum --- )

      1 OVER = IF DROP ." Sunday" ELSE

      2 OVER = IF DROP ." Monday" ELSE

      3 OVER = IF DROP ." Tuesday" ELSE

      4 OVER = IF DROP ." Wednesday" ELSE

      5 OVER = IF DROP ." Thursday" ELSE

      6 OVER = IF DROP ." Friday" ELSE

      7 OVER = IF DROP ." Saturday" ELSE

  DROP ;

  Step 4: Add as many THENs as there are ELSEs

: .WEEKDAY ( daynum --- )

      1 OVER = IF DROP ." Sunday" ELSE

      2 OVER = IF DROP ." Monday" ELSE

      3 OVER = IF DROP ." Tuesday" ELSE

      4 OVER = IF DROP ." Wednesday" ELSE

      5 OVER = IF DROP ." Thursday" ELSE

      6 OVER = IF DROP ." Friday" ELSE

      7 OVER = IF DROP ." Saturday" ELSE

  DROP THEN THEN THEN THEN THEN THEN THEN ;

Done! Ugly? Yes, but that's what a CASE..OF..ENDOF..ENDCASE 
construct internally looks like! Wrapping it in some slick 
keywords doesn't change that. If 4tH issues an error message 
saying that you're nesting too deep, you'll understand why. If 
you happen to convert a program that contains many 
CASE..OF..ENDOF..ENDCASE constructs it may be a bit tiresome, but 
remember you only have to do it once. If you don't feel like 
editing your source manually, you can use the script case24th.th 
to do the job for you. Finally, CASE..OF..ENDOF..ENDCASE is 
supported by the preprocessor[footnote:
See section [sec:The-preprocessor].
] as well.

21.3.10 DO..LOOP 

It is well-known in the Forth community that DO..LOOP is flawed. 
There have been several attempts to correct this, but they never 
got it right. On many occasions it even got worse. But why is 
DO..LOOP flawed?

'DO' puts the limit and the index on the Return Stack, but it 
doesn't decide whether the loop is actually entered. So, every 
loop is executed at least once. After each iteration 'LOOP' 
decides whether it iterates once more.

In our opinion it would have been better when 'DO' had made that 
decision (like any other language), but we can still live with 
that. The real trouble came with DO..+LOOP.

'+LOOP' is a logical extension. Every single language allows you 
to change the step. But contrary to what one might expect, 
'+LOOP' doesn't terminate when the loop limit is reached or 
exceeded, but when the loop index crosses "the boundary between 
the loop limit minus one and the loop limit".

What does that mean? Well, consider these three loops and try to 
predict what will be printed. Note: every loop is executed at 
least once:

( 1) 5 0 do i . 1 +loop cr 

( 2) 5 0 do i . -1 +loop cr 

( 3) -5 0 do i . -1 +loop cr

You would probably expect to see:

0 1 2 3 4 

0 

0 -1 -2 -3 -4

And that is what you get when you use 4tH. But this is not what 
you will get with ANS-Forth:

0 1 2 3 4 

0 -1 -2 -3 .. 6 5 

0 -1 -2 -3 -4 -5

The behaviour of the second loop is caused, because '+LOOP' 
doesn't take into account that it is counting down. So it 
iterates until the loop index reaches the loop limit by 
wrap-around arithmetic.

The behaviour of the third loop is caused by the ANS-Forth 
definition: the loop index must "cross the boundary between the 
loop limit minus one and the loop limit". In this case, the 
boundary is between -5 and -6.

DO..+LOOP didn't behave like this since the beginning of Forth: 
it was introduced in Forth-83. We preserved the Forth-79 
definition as closely as possible, because it is much more 
intuitive.

Some claim that ?DO..+LOOP will save it. As a matter of fact, it 
does. But only when the loop index and the loop limit are the 
same:

0 0 ?do i . loop

In that case the loop won't be entered. But it still won't save 
us for loops like this:

5 0 do i . -1 +loop cr

The authors of gForth claim that a whole host of new DO..LOOP 
words are the solution. We don't think so:

100 -100 do i . i 1+ 2/ negate +loop cr

The bottomline is: you can't let two words make the same 
decision. 4tHs '+LOOP' checks which direction it is going (up or 
down) and evaluates the loop arguments accordingly. We feel it is 
the best we can do for you.

Is there no way we can circumvent these problems? Yes, there is. 
It may not be too elegant or even fast, but it solves the 
problem. We just emulate C's for():

12 >r begin                               \ set up loop index 

  r@ 10 <                                 \ check loop limit 

while 

  r@ .                                    \ access loop index 

  r> 2+ >r                                \ increment loop index 

repeat                                    \ next iteration



r> drop cr                                \ drop loop index

Which is "equivalent" to:

10 12 ?do i . 2 +loop cr

Except that it works as expected. And as an extra bonus it is 
portable to ANS-Forth. Are these differences between the 
ANS-Forth and 4tH implementation of DO..LOOP really that 
important? Not in practice. Nobody really wants a loop that 
depends on wrap-around arithmetic, and you'll hardly ever see a 
'+LOOP' with a negative subscript. Everybody wants their programs 
to be understandable and maintainable, so the DO..LOOPs you'll 
encounter will usually be well-behaved.

21.3.11 I/O

It is trivial to define the ANS-Forth FILE wordset in 4tH, but 
almost impossible to do the opposite. So if you want to make a 
portable program use the ANS-Forth FILE wordset by including the 
ansfile.4th library file. The reason why 4tH uses a different I/O 
subsystem is twofold:

1. 4tH's I/O subsystem is far more powerful and elegant. Instead 
  of defining a whole new wordset, 4tH reuses most of the 
  available I/O words, like 'TYPE', 'EMIT', 'ACCEPT' and 'REFILL'[footnote:
As a matter of fact, a new set of words have been proposed that 
allow redirection of these words. 4tH already has that 
functionality.
], which is very Forth-like.

2. 4tH's I/O was initially quite primitive and this was the only 
  way to extend the system without breaking too much code.

This example is taken from gForth, but runs identically on both 
4tH and gForth:

[defined] 4th# [if]                    \ if this is 4tH, include

include lib/ansfile.4th                \ ANS Forth FILE wordset

include lib/compare.4th                \ and the word COMPARE 

[then]

  

[undefined] 4th# [if]                  \ if this is not 4tH,

s" lib/easy.4th" included              \ include 4tH 
compatibility

[then]

  

0 Value fd-in                          \ input file handle

0 Value fd-out                         \ output file handle

: open-input ( addr u -- )  r/o open-file throw to fd-in ;

: open-output ( addr u -- )  w/o create-file throw to fd-out ;

  

s" foo.in" open-input                  \ open input file

s" foo.out" open-output                \ open output file

  

: show 2dup type cr ;                  \ show the line

  

256 Constant max-line                  \ size of basic buffer

max-line 2 [+] string  line-buffer     \ extend by two bytes:

                                       \ ANS Forth requirement!

: scan-file ( addr u -- )

  begin                                \ read a line

      line-buffer max-line fd-in read-line throw 

  while                                \ is it identical?

      >r 2dup line-buffer r> show compare dup

  while                                \ if so, exit loop

      drop                             \ clean up

  repeat                               \ ANS requires an extra

[undefined] 4th# [if] then [then]      \ then after each WHILE

  drop 2drop 

;

                                       \ now scan the file

s" The text I search is here" scan-file

       

fd-in close-file throw                 \ close input file

fd-out close-file throw                \ close output file

Since section 11.3.12 of the ANS-Forth standard clearly states 
that an I/O exception shall not cause a 'THROW', we have to 
mention that 'FILE-SIZE', 'FILE-STATUS' and 'REPOSITION-FILE' are 
not entirely ANS-Forth compliant.

21.4 Easy 4tH 

4tH programs won't run on ANS-Forth all by itself. You'll usually 
need several definitions to make them work. In collaboration with 
Wil Baden we have developed an interface between ANS-Forth and 
4tH. It consists of two files, easy.4th and ezneeds.4th. These 
library files enable you to run most 4tH programs under 
ANS-Forth. In order to succesfully compile and run a 4tH program 
under ANS-Forth it must have been written with ANS-Forth in mind. 
The rest is simple: just add a couple of lines at the beginning 
of your 4tH program:

[UNDEFINED] 4TH# [IF] 

s" easy4th.4th" included 

[THEN]

That's all! Most of the 4tH words are now known to your very own 
ANS-Forth compiler. If your compiler already supports 'INCLUDE', 
you might be tempted to use:

[UNDEFINED] 4TH# [IF] 

include easy4th.4th 

[THEN]

This will actually work but since 4tH recognizes and acts on the 
'INCLUDE' directive, it will load the interface. A slight memory 
and CPU penalty is the result.

21.4.1 Enabling the String Space

Optionally, you can define a 'CONSTANT' before including Easy 
4tH, which enables support for arrays of string constants:

<size> constant /STRING-SPACE 

The parameter "SIZE" represents the size of the String Segment. 
When you decompile a 4tH program, it will show you exactly how 
much space is allocated to the String Segment. In order to port a 
single 4tH program, this is all the information you need!

4tH message : No errors at word 1105 

Object size : 1106 words 

String size : 2539 chars 

Variables   : 19 cells 

Strings     : 262 chars 

Reliable    : Yes

In this case the "/STRING-SPACE" must be at least 2539 bytes. So, 
give or take a few changes, let's say 3072 bytes. We advise you 
to allocate a little more memory than is strictly necessary. You 
can also use Easy 4tH to make ANS-Forth understand 4tH. Just 
type:

16384 constant /STRING-SPACE 

s" easy4th.4th" included

Now you can play around with ANS-Forth using the 4tH language. If 
you use a lot of string constants you might run out of space, but 
your ANS-Forth compiler will give you a message when that 
happens.

Note that - depending on the ANS-Forth compiler you're using - 
Easy 4tH may redefine some words, although it will try to 
minimize these redefinitions as much as possible.

21.4.2 The structure of Easy 4tH

Easy 4tH may look like a large program, but it isn't. It 
basically tries to figure out what your compiler supports and 
what is still left to define. It always prefers the native 
definition to its own. E.g. if your compiler already supports 
'PLACE', Easy 4tH will leave that definition intact and assume it 
has been defined correctly.

• Easy 4tH will start by defining several defining words like 
  'STRING', 'STRUCT' and 'ARRAY'. Since there is no standard 
  definition for these words, it will overwrite any existing 
  definition.

• After that, Easy 4tH will query the environment and define a 
  'CONSTANT' when successful. When not, a warning is issued.

• Several 4tH specific compiling words are defined. 

• Easy 4tH checks for the presence of several ANS-Forth and COMUS 
  words. If they are not there, they are defined. Warnings are 
  issued where applicable.

• In the next stage the parsing, conversion and time subsystems 
  of 4tH are defined. Warnings are issued where applicable.

• All 4tH words that cannot be defined in ANS-Forth are marked as 
  unsupported. When used, an error message is issued and 
  compilation aborted.

• ezneeds.4th is loaded and '[NEEDS' and 'INCLUDE' are defined if 
  needed.

Note that your own compiler may issue error messages or warnings 
too, e.g. about redefinitions.

21.5 The preprocessor<sec:The-preprocessor>

The preprocessor[footnote:
See section [cha:Preprocessor-manual].
] (PP4tH) is also a very useful tool to make ANS-Forth compliant 
programs, especially when double numbers or floating point 
numbers are involved. The preprocessor supports a lot of 
ANS-Forth words which are not supported by 4tH like ”SYNONYM”, ”
ACTION-OF”, etc. It allows you to enter double numbers or 
floating point constants with ease, provided you included the 
proper preprocessor library, e.g.:

f% 234.34e-2

Yes, ”F%” isn't ANS-Forth either, but a very small library 
enables your ANS-Forth compiler to compile these numbers without 
any additional overhead, e.g.:

[DEFINED] 4TH# [IF]

include 4pp/lib/float.4pp

[ELSE]

s" lib/ezpp4th.4th" included

[THEN]

  

f% 234.34e-2 f. cr

For your convenience, those words are ”state smart”, so you can 
use them both inside and outside definitions as this sample 
session shows you:

Gforth 0.6.2, Copyright (C) 1995-2003 Free Software Foundation, 
Inc.

Gforth comes with ABSOLUTELY NO WARRANTY; for details type 
`license'

Type `bye' to exit

[DEFINED] 4TH# [IF]  ok

include 4pp/lib/float.4pp  ok

[ELSE]  ok

s" lib/ezpp4th.4th" included  ok

[THEN]  ok

f% 234.34e-2 f. cr 2.3434

 ok

: test f% 234.34e-2 f. cr ;  ok

test 2.3434

 ok

see test

: test

  2.343400E0 f. cr ; ok

Of course, you can write double number or floating point programs 
without the preprocessor, but they will contain a lot of ”noise” 
words and are neither easy to read nor to maintain. Using the 
preprocessor really simplifies your life in these circumstances.

21.6 Converting ANS-Forth programs to 4tH

4tH is a subset of ANS-Forth, so it might be difficult to find a 
program that will run on 4tH without at least some rewriting. And 
there is no guarantee that it will work, because most ANS-Forth 
programs weren't written with 4tH in mind. We'll list the major 
pitfalls:

• Programs requiring unsupported words or most words from the 
  FACILITY, FACILITY EXT, SEARCH and SEARCH EXT wordsets are 
  generally impossible to port.

• Definitions manipulating the dictionary or the stacks. But 4tH 
  has no dictionary and does not allow direct access to the 
  stacks.

• Definitions that switch between interpretation and compilation 
  mode. 4tH either interprets or compiles; you cannot switch 
  between the two on the fly. User-defined 'IMMEDIATE' words 
  generally don't work.

• Definitions using 'CREATE' and 'DOES>' can be difficult to 
  port. The only way is to do the 'CREATE' part manually and wrap 
  the 'DOES>' part into a ':REDO' definition. Another way to port 
  this kind of code is to resort to the 4tH preprocessor.

• Definitions requiring the LOCAL and LOCAL EXT wordsets are 
  difficult to port. You'll need to rewrite them extensively by 
  using the locals.4th library file.

• Definitions using ANS-Forth enhanced flow control require some 
  rewriting and conditional compilation.

• Programs that assume they may store cells and characters in the 
  same dataspace require some rewriting. Use the ncoding.4th 
  library file.

Errors guide

22.1 How to use this manual

This manual contains all the error messages 4tH can possibly 
issue. It is organized like this:

Message: This features the message from errs_4th.c, the 
error-code returned in ErrNo and the C-mnemonic.

Words: Words that can trigger this error.

Example: This features a 4tH one-liner that will trigger the 
error.

Cause: This lists all possible causes of the error.

Hints: This will give you some directions on how to fix the 
error.

22.2 Interpreter (exec_4th)

When exiting this function ErrLine will contain the address of 
the word in the Code Segment where the error occured.

Message: No errors (#0 M4NOERRS)

Words: Not applicable

Example: Not applicable

Cause: A program was succesfully executed.

Hints: Make an error ;)





Message: Out of memory (#1 M4NOMEM)

Words: Not applicable

Example: Not applicable

Cause: There was not enough free memory to allocate the Character 
Segment or the Integer Segment.

Hints: 

1. Reduce the amount of memory your program allocates and 
  recompile.

2. Add more physical memory or increase swap space.

3. Recompile 4tH under another operating system (flat memory 
  space) or another memory model.





Message: Bad object (#2 M4BADOBJ)

Words: Not applicable

Example: Not applicable

Cause: An unknown token was encountered in the H-code.

Hints: Contact us, this should never happen.





Message: Stack overflow (#3 M4SOVFLW)

Words: Any word that pushes items on the Data Stack.

Example: STACK 1+ 0 DO I LOOP

Cause: The Data Stack collided with the Return Stack.

Hints:

1. Don't push too many elements on the Data Stack.

2. Merge colon-definitions. Reduce the number of nested 
  DO..LOOPs.

3. If you are using recursion, try if you can achieve the same 
  result with a loop.

4. Make sure that your stacks are still balanced when returning 
  from a colon-definition. Don't leave any unused data on the 
  Data Stack. Flow-control words can have unexpected stack 
  effects!





Message: Stack empty (#4 M4SEMPTY)

Words: Any word that pops items from the Data Stack.

Example: 0 SWAP

Cause: The Data Stack did not contain the required number of 
items to complete the operation.

Hints:

1. Make sure that your stack is still balanced when returning 
  from a colon-definition.

2. Make sure that the required number of items are on the stack 
  when performing the operation.

3. If the problem occurs within an interpreter driven 
  application, make sure that you check the number of elements 
  are on the stack before allowing the operation.





Message: Return stack overflow (#5 M4ROVFLW)

Words: Any word that pushes items on the Return Stack; calling a 
user defined word

Example: : DUMMY DUMMY ; DUMMY

Cause: The Return Stack collided with the Data Stack.

Hints: 

1. Don't push too many elements on the Data Stack.

2. Merge colon-definitions. Reduce the number of nested 
  DO..LOOPs.

3. If you are using recursion, try if you can achieve the same 
  result with a loop.

4. Make sure that your stacks are still balanced when returning 
  from a colon-definition. Don't leave any unused data on the 
  Data Stack. Flow-control words can have unexpected stack 
  effects!





Message: Return stack empty (#6 M4REMPTY)

Words: Any word that pops items from the Return Stack; returning 
from a user defined word

Example: R>

Cause: The Return Stack did not contain the required number of 
items to complete the operation.

Hints:

1. Balance R> and >R inside your colon-definition. Flow-control 
  words can have unexpected stack effects!

2. Be careful when using R> and >R inside a DO..LOOP.





Message: Bad string (#7 M4BADSTR)

Words: ARGS OFFSET

Example: -1 ARGS

Cause: There was either no argument on the command line or no 
binary string constant with this index.

Hints:

1. Use a valid index for ARGS.

2. Use a valid index for the offset.





Message: Bad variable (#8 M4BADVAR)

Words: ! @ +! ? SMOVE

Example: 6 ARRAY NAME NAME -5 TH @

Cause: You tried to access a variable or array element, but its 
address in the Integer Segment is invalid.

Hints: 

1. Be sure that all stack-items are in the right order when 
  address calculations, fetches or stores are made.

2. Use a valid array index or address.

3. Don't transfer any cells to or from a invalid array index or 
  address.

4. Don't try to overwrite read-only system variables.





Message: Bad address (#9 M4BADADR)

Words: All string handling words

Example: 10 STRING BUFFER TIB CHAR- BUFFER /TIB CMOVE

Cause: You tried to access a character, but its address in the 
Character Segment is invalid.

Hints:

1. Be sure that all stack-items are in the right order when 
  address calculations, fetches or stores are made.

2. Make sure that the number of elements is correct when you use 
  words like CMOVE, COUNT, FILL.

3. Terminate strings.

4. You exceeded the maximum length of PAD when you defined a 
  string constant using S".

5. You exceeded the maximum length of PAD when you fetched a 
  commandline argument using ARGS.





Message: Divide by zero (#10 M4DIVBY0)

Words: / MOD /MOD */ */MOD

Example: 1 0 / . CR

Cause: You tried to divide by zero.

Hints: Check the divisor before you use it.





Message: Bad token (#11 M4BADTOK)

Words: @C EXECUTE EXIT CATCH

Example: : DUMMY ; ' DUMMY 5 - DUP @C SWAP EXECUTE

Cause: You tried to jump to a token or access the argument of a 
token, but its address in the Code Segment is invalid.

Hints:

1. Be sure that all stack-items are in the right order when 
  address calculations, fetches or jumps are made.

2. Make sure the address you're using is within the Code Segment.

3. Be sure that the name after ' is that of a colon-definition.





Message: I/O error (#14 M4IOERR)

Words: All words performing I/O

Example: OUTPUT FILE 5 . CR

Cause:

1. You tried to read from or write to an unopened file.

2. You tried to USE, SEEK or TELL an unused stream.

3. There was an I/O error when you tried to read from or write to 
  a file.

4. There was an error when you tried to close an open file with 
  CLOSE.

5. There was an error when 4tH tried to close a file after the 
  program terminated.

Hints:

1. Open a file before you try to read or write to it. Check the 
  value OPEN returns.

2. Make sure the values on the stack are correct when you perform 
  I/O.

3. Make sure the values on the stack are correct when addressing 
  streams.

4. Make sure that there is enough space left on the device you 
  try to write to. Make sure it functions correctly.





Message: Assertion failed (#15 M4ASSERT)

Words: )

Example: [ASSERT] ASSERT( FALSE )

Cause: The top of the stack was FALSE when ) executed.

Hints: Correct the condition ) acted upon.





Message: Unhandled exception (#16 M4THROW)

Words: THROW

Example: 1 THROW

Cause: A THROW was encountered without a previous call from 
CATCH. The top of stack contained an error number outside the 
range of system errors.

Hints: Make sure that a THROW can only be reached from a previous 
CATCH.





Message: Bad radix (#17 M4BADRDX)

Words: .R . # NUMBER

Example: 1 BASE ! 5 . CR

Cause: The 4tH variable BASE contained a value outside the 2 to 
36 range during a conversion.

Hints: Take care that BASE stays within the 2 to 36 range.





Message: Bad stream (#18 M4BADDEV)

Words: USE SEEK TELL CLOSE

Example: -1 CLOSE

Cause: 

1. The filehandle you tried to use was out of range.

2. You may not SEEK, TELL or CLOSE the streams STDIN and STDOUT.

3. You may not SEEK or TELL a pipe.

Hints: 

1. Make sure you use a proper stream when using USE, SEEK, TELL 
  or CLOSE.

2. Check stack manipulations or use a variable or value.

Message: Bad pointer (#20 M4BADPTR)

Words: CATCH THROW PAUSE

Example: : ME R> R> R> DROP -5 >R >R >R 1 THROW ; ' ME CATCH

Cause: The stack pointer THROW or PAUSE tried to use was invalid.

Hints:

1. Be careful when you manipulate the Return Stack.

2. Contact us, this should never happen.





22.3 Compiler (comp_4th)

When exiting this function ErrLine will contain the address in 
the Code Segment where the next word would have been compiled if 
the error hadn't occured. This is logical, since 4tH always 
reports where the error occured. And all previous words have been 
succesfully compiled.

Message: No errors (#0 M4NOERRS)

Words: Not applicable

Example: Not applicable

Cause: A source was succesfully compiled.

Hints: Make an error ;)





Message: Out of memory (#1 M4NOMEM)

Words: Not applicable

Example: Not applicable

Cause: There was not enough free memory to allocate the H-code 
header, the Code Segment, the symbol-table or the control-stack.

Hints:

1. Compact your source by removing all comment and whitespace or 
  use the preprocessor[footnote:
See chapter [cha:Preprocessor-manual].
].

2. Add more physical memory or increase swap space.

3. Recompile 4tH under another compiler (flat memory space) or 
  another memory model.





Message: Bad object (#2 M4BADOBJ)

Words: All defining words

Example: CR CR 20 STRING

Cause:

1. A word could not be compiled due to lack of space in the Code 
  Segment.

2. A definition could not be compiled due to lack of space in the 
  symbol-table.

Hints:

1. Trying to make words private by using conditional compilation 
  may trigger this error. Remove the offending HIDE.

2. In certain circumstances, incomplete data declarations may 
  trigger this error. Complete the declaration.

3. Contact us, this should never happen with normal source-code.





Message: Bad string (#7 M4BADSTR)

Words: SCONSTANT

Example: 6 SCONSTANT BAD

Cause: The expression, which was compiled right before the word 
which caused the error, was not a string constant created by S" 
or S|.

Hints: Use a string constant created by S" or S|.





Message: Bad variable (#8 M4BADVAR)

Words: EQUATES

Example: 6 EQUATES BAD

Cause: The expression, which was compiled right before the word 
which caused the error, did not compile to a variable.

Hints: Use a expression, which compiles to a variable.





Message: Divide by zero (#10 M4DIVBY0)

Words: / /CONSTANT

Example: 0 /CONSTANT WRONG 1 WRONG

Cause: 

1. You tried to divide by zero in a literal expression.

2. You tried to apply a zero /CONSTANT.

Hints: 

1. Check the divisor before you use it.

2. Don't define a zero /CONSTANT.





Message: Wrong type (#12 M4NOTYPE)

Words: TO IS ALIAS DEFER FILE VALUE :REDO DOES> TAG

Example: 0 CONSTANT WRONG 5 TO WRONG

Cause:

1. The name after TO isn't a VALUE.

2. The name after IS isn't a DEFER.

3. The name after DEFER or ALIAS is already defined and not a 
  DEFER.

4. The name after VALUE or FILE is already defined and not a 
  VALUE.

5. You tried to create a :REDO or DOES> definition for an 
  unsupported datatype.

6. The name after TAG isn't an OFFSET.

Hints:

1. Use TO only in combination with a VALUE.

2. Use IS only in combination with a DEFER.

3. Use a different name.

4. Use a different name.

5. Use a proper datatype when creating a :REDO or DOES> 
  definition.

6. Use TAG only in combination with an OFFSET.





Message: Undefined name (#13 M4NONAME)

Words: <name> ' ['] RECURSE AKA HIDE

Example: ' HELLO ( "hello" is not defined)

Cause:

1. The name which caused the error is not present in the 
  symbol-table.

2. The name is not defined at all.

3. It is not a valid number in the current radix.

4. Underflow or overflow occured during number conversion.

5. RECURSE is used outside a colon definition.

6. The name you used is longer than WIDTH characters.

Hints:

1. Note that most of the words above only work with names defined 
  inside the program and not with built-in names[footnote:
AKA does offer limited capability in this field.
].

2. Usually a typo; correct spelling.

3. Set the appropriate radix by using [BINARY], [OCTAL], 
  [DECIMAL] or [HEX].

4. Don't use numbers less or equal to (ERROR) or greater than 
  MAX-N.

5. Remove the offending RECURSE.

6. Use a shorter name.





Message: I/O error (#14 M4IOERR)

Words: [NEEDS INCLUDE

Example: [NEEDS nosuchfile.4th]

Cause:

1. The source file you tried to read doesn't exist.

2. There was an error reading the source file.

3. There was an error when 4tH tried to close the source file.

Hints:

1. Make sure the file you try to open exists and is in the path. 
  Change your working directory if necessary. Check the DIR4TH 
  environment variable.

2. Make sure the device functions correctly.





Message: Bad literal (#19 M4BADLIT)

Words: All words requiring a literal expression

Example: 10 DUP ARRAY NAME

Cause: The expression, which was compiled right before the word 
which caused the error, did not compile to a literal.

Hints: Use a literal expression.





Message: Nesting too deep (#21 M4NONEST)

Words: All flow control words and colon definitions

Example: 10 0 DO 10 0 DO <more flow-control structures> LOOP LOOP

Cause: The control-stack, that holds all references to addresses 
of flow-control structures in the Code Segment, overflowed.

Hints: Make separate colon-definitions of the flow-control 
structures that caused the error.





Message: No program (#22 M4NOPROG)

Words: All words that do not compile any tokens

Example: 10 ARRAY NAME ( Won't compile)

Cause:

1. The source didn't contain any compilable words.

2. The source was corrupt.

3. A runaway comment or conditional compilation clause.

4. In rare cases use of reserved words as names.

Hints:

1. Make a program that does something.

2. Make sure that the source actually contains 4tH source- code.

3. Terminate your comments and conditional compilations properly.

4. Don't use any reserved words as names.





Message: Incomplete declaration (#23 M4NODECL)

Words: All defining words and compiler directives

Example: 10 CONSTANT CONSTANT NAME

Cause:

1. Syntax errors; usually a missing name or a literal expression.

2. Incomplete compiler directives or expressions, like a leading 
  comma or a trailing CHAR.

3. An assertion, beginning with ASSERT(, is missing a right 
  parenthesis. Assertions are not enabled at that point.

4. An [IF] is not balanced by a [THEN].

Hints:

1. Use an appropriate expression or name.

2. Complete compiler directives and expressions.

3. Add a right parenthesis at the end of the expression.

4. Add a [THEN] for each [IF] statement.





Message: Unmatched conditional (#24 M4NOJUMP)

Words: All flow control words and colon definitions

Example: : WRONG IF DROP BEGIN FALSE LOOP ;

Cause: The flow-control word that caused the error didn't match 
with the previous flow-control word (BEGIN after IF) or was 
missing.

Hints: Use the appropriate flow-control word to terminate a 
flow-control structure.





Message: Unterminated string (#25 M4NOSTR)

Words: ." \ ( .( ," S" ABORT" S| ,| [CHAR] CHAR @GOTO [NEEDS 
INCLUDE [DEFINED] [UNDEFINED]

Example: ." Hello world

Cause:

1. A required delimiter is missing at the end of a string.

2. An internal error occured at the very end of the source.

Hints:

1. Add the required delimiter at the end of the string.

2. Contact us, this should never happen.





Message: Null string (#26 M4NULSTR)

Words: See error #25

Example: ." "

Cause: 

1. The string between the word and its delimiter did not contain 
  any characters.

2. There was more than one whitespace character between a 
  [DEFINED], [UNDEFINED], [CHAR], CHAR or INCLUDE and the string 
  following it.

Hints:

1. Use a string that contains at least one single character.

2. Delete all superfluous whitespace characters between 
  [DEFINED], [UNDEFINED], [CHAR], CHAR or INCLUDE and the string 
  following it.





Message: Duplicate name (#27 M4DUPNAM)

Words: All defining words

Example: : TH CELLS + ;

Cause: The name you used for a definition is already in use by 
4tH or your own program.

Hints: Use a different name.





Message: Name too long (#28 M4BADNAM)

Words: All defining words

Example: VARIABLE JUSTTOOLONGANAMEFORCOMFORT

Cause: The name you used for a definition is too long.

Hints: Use a shorter name.





Message: Compilation aborted (#29 M4CABORT)

Words: [ABORT]

Example: [ABORT]

Cause: An [ABORT] directive was encountered during compilation.

Hints: The original programmer must have had a reason to abort 
compilation in this particular circumstance. See the program for 
additional information.

22.4 Loader (load_4th)

Since the loader works with complete segments, the words don't 
have to do much with fixing an error. Therefore, it reports that 
nothing has been loaded (word 0) or everything has been loaded 
(the last word).

Message: No errors (#0 M4NOERRS)

Words: Not applicable

Example: Not applicable

Cause: A program was succesfully loaded.

Hints: Keep up the good work. ;)





Message: Out of memory (#1 M4NOMEM)

Words: Not applicable

Example: Not applicable

Cause: There was not enough free memory to allocate the header, 
the Code Segment or the String Segment.

Hints:

1. Reduce the amount of memory your program allocates and 
  recompile.

2. Add more physical memory or increase swap space.

3. Recompile 4tH under another compiler (flat memory space) or 
  another memory model.





Message: Bad object (#2 M4BADOBJ)

Words: Not applicable

Example: Not applicable

Cause: 

1. You tried to load a file, that was not an HX-file.

2. You tried to load an HX-file from a previous version of 4tH.

3. You tried to load an HX-file for a different application.

4. You tried to load an HX-file for a different architecture.

5. You tried to load an inconsistent HX-file.

Hints:

1. Use a proper HX-file.

2. Recompile the source, using the current 4tH compiler.

3. If the source is compatible, you might recompile the source, 
  using your own 4tH compiler.

4. If the source is compatible, you might recompile the source, 
  using your own 4tH compiler.

5. Recompile the source, using your own 4tH compiler.





Message: I/O error (#14 M4IOERR)

Words: Not applicable

Example: Not applicable

Cause:

1. The file could not be opened.

2. There was an I/O error while the file was read.

3. The file could not be closed.

Hints:

1. Use a valid filename.

2. Make sure the device functions correctly.

3. Make sure the device functions correctly.

22.5 Saver (save_4th)

Since the saver works with complete segments, the words don't 
have to do much with fixing an error. Therefore, it reports that 
nothing has been saved (word 0) or everything has been saved (the 
last word).

Message: No errors (#0 M4NOERRS)

Words: Not applicable

Example: Not applicable

Cause: A program was succesfully saved.

Hints: Keep up the good work. ;)





Message: I/O error (#14 M4IOERR)

Words: Not applicable

Example: Not applicable

Cause:

1. The file could not be opened.

2. There was an I/O error while the file was written.

3. The file could not be closed.

Hints: 

1. Make sure you got enough inodes or directory-entries left on 
  the device you want to write to. Use a valid filename.

2. Make sure that there is enough space left on the device you 
  try to write to. Make sure it functions correctly.

3. Make sure the device functions correctly.

4tH library

23.1 4tH library files

This list contains all the 4tH library files with short 
descriptions of their functionality. If a file only contains 
ANS-Forth words, these words are listed.

3dup3rot.4th Standard stack operators for maniplulating three 
stack items.

acker.4th An implementation of the Ackermann function.

acptword.4th Read a word from a file, regardless of linebreaks.

adler32.4th A port of the FFL ”Adler 32 checksum” module.

allsheet.4th Write CSV, XLS, XML, KSP, FODS or HTML spreadsheet 
files.

ansblock.4th BLK, UPDATE, CLEAR, EMPTY-BUFFERS, SAVE-BUFFERS, 
FLUSH, BLOCK, BUFFER, LIST

anscore.4th 2!, 2@, 2OVER, 2ROT

ansdbl.4th U<, U>, D+, D2*, DNEGATE, D-, D<, DABS, D2/, DU<, D=, 
D0<, D0=, DMAX, DMIN 

ansfacil.4th TIME&DATE, MS

ansfile.4th FILE-SIZE, READ-LINE, OPEN-FILE, CLOSE-FILE, 
FILE-POSITION, REPOSITION-FILE, READ-FILE, WRITE-FILE, 
FLUSH-FILE, WRITE-LINE, FILE-STATUS, CREATE-FILE, BIN, R/O, W/O, 
R/W

ansfloat.4th FLOAT, F2/, F2*, PRECISION, SET-PRECISION, FCLEAR, 
FDEPTH, FDUP, FDROP, FNEGATE, D>F, F>D, FLOAT+, FLOATS, F@, F!, 
FSIGN?, F0=, F0<, FABS, FALIGN, FALIGNED, FSWAP, FPICK, FNIP, 
FROT, F+, F-, F<, F=, FLOOR, FROUND, FMIN, FMAX, F*, F/, F~, 
FSQRT

ansfpio.4th F., R., FS., FE., >FLOAT, F.S

ansmem.4th ALLOCATED, FREE, PARAGRAPH, ALLOCATE, RESIZE

ansquote.4th An implementation of an S\" like word.

ansren.4th RENAME-FILE

anstools.4th .S

arcfour.4th An implementation of the RC4 encryption algorithm.

argopen.4th Allows you to easily open files, whose names were 
listed on the command line.

ascii7.4th Filtering strings to the ASCII-7 subset.

asciixml.4th Conversion of XML character entities.

asinacos.4th FATAN, FASIN, FACOS

back.4th The TOOLBELT implemention of the backward string 
tokenizing words -SCAN and BACK.

backtrak.4th An implementation of the backtracking words by M.L. 
Gassanenko.

banners.4th An implementation of the Unix 'banner' functionality.

base64.4th Base64 encoding and decoding words.

basename.4th Several POSIX basename(), dirname() like words.

binomial.4th An implementation of binomial coefficients and 
Catalan numbers.

bitarray.4th An implementation of bit arrays.

bitfield.4th An implementation of bitfields.

bits.4th Several words to manipulate individual bits.

bitset.4th Several BSD ffs(), fls() like words.

boxes.4th Places ASCII boxes around strings.

breakq.4th Tests for character equality in a string.

bsearch.4th An implementation of a binary search.

bub2sort.4th An implementation of the bubble sort algorithm.

bublsort.4th An implementation of the bubble sort algorithm.

buffer.4th An implementation of user-defined ring buffers.

capitals.4th Converts strings to CaMeL case.

cards.4th A library which allows you to easily implement card 
games.

charat.4th Some strchr() like words.

chars.4th All printable ASCII-7 characters turned into constants.

chi2.4th Several ”Chi square” related floating point functions.

chmatch.4th A library with regular expression like words.

choose.4th Some words that return a random number within a 
user-defined range.

coc2sort.4th An implementation of the optimized cocktail sort 
algorithm.

cocksort.4th An implementation of the cocktail sort algorithm.

com2sort.4th An implementation of the ”comb sort with a different 
ending” algorithm.

combsort.4th An implementation of the ”comb sort with a different 
ending” algorithm.

compare.4th COMPARE

comus.4th Some well known COMUS words.

concat.4th Concatenate multiple character strings.

constant.4th Several constants.

convert.4th A template which allows you to easily create simple 
conversion programs.

countstr.4th Support for ANS-Forth counted strings.

cp437htm.4th Converts CP437 characters to HTML character 
entities.

crc.4th An implementation of the CRC16 encoding.

cstring.4th Extracting characters from the beginning or the end 
of a string.

csvfrom.4th Converts a string with embedded double (CSV escaped) 
quotes.

csv-w.4th Write CSV files.

ctos.4th Converts a character to a string.

cyclsort.4th An implementation of the cycle sort algorithm.

date2xls.4th Converts Julian dates to/from the Excel-1900 format.

dblbin.4th Double word binary operations.

dbldiv.4th Double word divisions.

dbldot.4th D.R, D., U.R, U. 

dblsharp.4th Double word equivalents of the <#, #>, SIGN, # and 
#S words.

dbm.4th A tiny database management system.

dbmsort.4th A sorting extension to the tiny DBM.

ddigroot.4th Calculates OEIS A010888 sequence and additive 
persistence of double cell numbers.

ddotf.4th Prints double numbers as floating point numbers.

debug.4th An implementation of a breakpoint debugger.

digiroot.4th Calculates OEIS A010888 sequence and additive 
persistence of single cell numbers.

digit.4th Converts a numeric character to its numeric equivalent.

dsqrt.4th Double word square root.

dst.4th Determines ”daylight saving time” in the US and EU.

dump.4th DUMP

dumpbase.4th DUMP

easter.4th Calculates the date of Easter for a given year.

easy.4th An ANS-Forth library to port 4tH programs to ANS-Forth.

ellipint.4th An implementation of the Complete Elliptic Integrals 
functions.

embed.4th Converts a string with embedded ASCII codes.

emits.4th Emits a single character several times.

enter.4th Enter a number from the keyboard.

environ.4th ENVIRONMENT?

erf.4th A high accuracy implementation of the erf() function.

erf1.4th An alternative implementation of the erf() function.

escape.4th Converts a string with embedded escape codes.

evaluate.4th SAVE-INPUT, RESTORE-INPUT, EVALUATE

exceptn.4th A minimal implementation of the Sourceforge library 
extention to the ANS EXCEPTION wordset.

expout.4th Simple floating point exponential output library.

ezneeds.4th Part of the ANS-Forth library to port 4tH programs to 
ANS-Forth (easy.4th).

ezpp4th.4th An ANS-Forth library defining the preprocessor 
prefixes D% and F%.

falog.4th F**, FALOG

fatan2.4th FATAN2

fatanh.4th FASINH, FACOSH, FATANH

fbeta.4th An implementation of the Complete Beta function.

fbetacdf.4th An implementation of the Incomplete Beta function.

fbetapdf.4th An implementation of the Beta Probability density 
function.

fcartes.4th Cartesian to polar coordinates conversion.

fcbrt.4th An implementation of the floating point cube root 
function.

fdeg2rad.4th Degrees to radians conversion (and vice versa).

felip.4th An implementation of the Complete Elliptic Integral 
function.

fenter.4th Enter a floating point number from the keyboard.

fequals.4th An implementation of several extended floating point 
comparison words.

ferf.4th An implementation of the erf() function.

fexp.4th FEXP

fexpint.4th An implementation of the Real Exponential Integral 
function.

fexpm1.4th FEXPM1

fexpt.4th FEXP

ffl-frc.4th An implementation of words for using fractions.

fhaversn.4th An implementation of the haversine formula.

figures.4th Prints out numbers in full English words.

files.4th Several words for querying and manipulating files.

filestat.4th An interface to the Unix stat command.

filter.4th Filters out certain characters from a string.

fixeddot.4th Prints out numbers in fixed point notation.

flnflog.4th FLN, FLOG

flnflogb.4th FLN, FLOG

flnp1.4th FLNP1

flogist.4th An implementation of the logistic function and its 
first derivative.

forwdiff.4th An implementation of the forward difference 
function.

fp0.4th Floating point configuration 0.

fp1.4th Floating point configuration 1.

fp2.4th Floating point configuration 2.

fp3.4th Floating point configuration 3.

fp4.4th Floating point configuration 4.

fpconst.4th Several floating point constants.

fpdot.4th Floating point pictured numeric output operators.

fpin.4th >FLOAT

fpolar.4th Polar to Cartesian coordinates conversion.

fpout.4th FS., FS.R, (FS.), FE., FE.R, (FE.), F., F.R, (F.), G., 
G.R, (G.)

fpow.4th Fast initialization of ANS floating point constants with 
extreme exponents.

fpow10.4th Fast initialization of ANS floating point base 10 
constants with extreme exponents.

fq.4th An implementation of the ”Q” function.

fracout.4th Simple fixed-point output with optional thousands 
separator.

fraction.4th An implementation of fractional arithmatic words.

frexp.4th Several frexp(), ldexp() like words.

fsincost.4th FSIN, FCOS, FSINCOS, FTAN

fsinfcos.4th FSIN, FCOS, FSINCOS, FTAN

fsl-util.4th The utilities for the Forth Scientific Library.

fsm.4th Finite States Machines, Julian Noble style.

ftrunc.4th FTRUNC, FCEIL

fvector.4th Several ANS floating point vector functions.

fwt.4th A port of the FFL ”fixed width types” module.

fzeta.4th An implementation of the Riemann zeta function.

gamma.4th An implementation of the gamma, loggamma and reciprocal 
gamma functions.

gammaln.4th An implementation of the Lanczos loggamma function.

gammapq.4th An implementation of the Incomplete Gamma function.

gauss.4th An implementation of the Gaussian (normal) probablity 
functions.

gbanner.4th Graphic character output, part of Portable Bitmap 
graphics suite.

gbk2utf8.4th Converts GBK/2 encoded strings to UTF8.

gc.4th A simple ”mark-and-release” garbage collector.

gcdlcd.4th An implementation of the least and greatest common 
denominator functions.

gcol2gry.4th Color to grayscale conversion, part of the Portable 
Bitmap graphics suite.

getenv.4th A getenv() like word.

getopts.4th Some getopt() like words.

gmkiss.4th A high performance random number generator.

gmskiss.4th An even higher performance random number generator.

gno2sort.4th An implementation of an optimized gnome sort 
algorithm.

gnomsort.4th An implementation of the gnome sort algorithm.

graphics.4th An implementation of Portable Bitmap graphics 
functions.

gshrink.4th Halves the dimensions of an image, part of the 
Portable Bitmap graphics suite.

gtkipc.4th An alternative interface to GTK-server.

gtkserv.4th An interface to GTK-server.

gturtle.4th An implementation of Turtle graphics, part of the 
Portable Bitmap graphics suite.

gview.4th Show an image in ASCII, part of the Portable Bitmap 
graphics suite.

hamming.4th An implementation of the Hamming (7,4) linear 
error-correcting codes.

harshad.4th Identifies Harshad numbers.

hash.4th An implementation of several well known hash functions.

hashbuck.4th An implementation of hash tables with buckets.

hashtabl.4th An implementation of hash tables without buckets.

headings.4th An implementation of ”boxing the compass”.

hea2sort.4th An implementation of the heap sort algorithm.

heapsort.4th An implementation of the heap sort algorithm.

hiorder.4th Several high order words.

hms2secs.4th Decodes time strings.

holds.4th HOLDS

horner.4th An implementation for evaluation of a polynomial by 
the Horner method.

html.4th Create simple HTML 4.01 Transitional formatted files.

html-w.4th Writes tables to HTML 4.01 Transitional formatted 
files.

huntjoin.4th The TOOLBELT implemention of the string replacing 
words HUNT and JOIN.

i8859htm.4th Converts ISO-8859 characters to HTML character 
entities.

idsystem.4th Differentiating between Microsoft and POSIX OSes.

info.4th A library for making Unix man like information systems.

instsort.4th An implementation of the insert sort algorithm.

interprt.4th A library for making simple Forth-like interpreters.

intpfile.4th A library for interpreting Forth-like scripts from 
file.

isdate.4th Checks whether a date is valid.

isprime.4th Checks whether a number is a prime number.

istype.4th Several isalnum(), isalpha(), isascii(), isdigit() 
like words.

kaprekar.4th Checks whether a number is a Kaprekar number.

key.4th KEY, KEY?

koksp-w.4th Write KOffice KSpread XML 1.x files.

latex.4th Create simple LaTeX files.

leading.4th Strips leading spaces from a string.

legacy.4th An implementation of the legacy word CONVERT.

license.4th Prints the GPLv2 license.

lists.4th An implementation of LISP-like list functions.

locals.4th A library for implementing local variables.

logger.4th Write Linux-like log-files.

logtime.4th Format the current time and date as in Linux 
log-files.

longjday.4th Prints a date in a long or short format.

luhn.4th Performs the Luhn test, which is used by some credit 
card companies to distinguish valid credit card numbers.

lz77.4th An implementation of the 1977 Ziv-Lempel file 
compression algorithm.

m3todate.4th Converts a large number of ”DD-MMM-YY(YY)” strings 
to day, month, year format.

math.4th Several integer math words.

mbinoml.4th An implementation of binomial coefficients and 
Catalan numbers.

md5.4th A port of the FFL ”MD5 checksum” module.

memcell.4th ALLOCATED, FREE, ALLOCATE, RESIZE

memchar.4th ALLOCATED, FREE, ALLOCATE, RESIZE

menu.4th A library for creating simple menus.

mergsort.4th An implementation of the merge sort algorithm.

message.4th A more complete implementation of the Sourceforge 
library extention to the ANS EXCEPTION wordset.

mixed.4th UM/MOD, FM/MOD, SM/REM, UM*, M*, M*/, M+, MU*, MU/MOD

mon3date.4th Formats a date in the DD-MMM-YYYY notation.

morse.4th Words for encoding and decoding Morse signs.

msxls2-w.4th Write MS-Excel 2.1 files.

msxmls-w.4th Write MS-Excel XML 2003 files.

multiblk.4th BLK, UPDATE, CLEAR, EMPTY-BUFFERS, SAVE-BUFFERS, 
FLUSH, BLOCK, BUFFER, LIST

ncoding.4th A library for storing numbers in character buffers.

norm-pdf.4th An implementation of several Probability Density 
functions.

ntor.4th Saves or retrieves several values to or from the return 
stack.

obsolete.4th #TIB, EXPECT, QUERY

oofods-w.4th Write OpenOffice FODS files.

opgftran.4th Infix to postfix formula translation.

ordidate.4th An implementation of several ”ordinal date” and week 
functions.

padding.4th Pads strings and prints padded strings.

palette.4th Several Portable Bitmap palette manipulation words.

palindrm.4th Checks whether a string is a palindrome.

pancsort.4th An implementation of the pancake sort algorithm.

pangram.4th Checks whether a string is a pangram.

parsexml.4th A library which allows easy parsing of XML and HTML 
files.

parsing.4th Several enhanced parsing words.

parsname.4th An implementation of PARSE-NAME, which allows 
parsing regardless of whitespace character.

pcylfun.4th An implementation of parabolic cylinder functions U 
and V, plus related confluent hypergeometric functions.

perfect.4th Checks whether a number is a perfect number.

permcomb.4th An implementation of permutations and combinations.

perrin.4th An implementation of the Perrin sequence.

pickroll.4th PICK, ROLL, ?DUP

picture.4th An implementation of pictured numeric output words.

placelne.4th Parse a buffer and copy the resulting line to a 
string variable.

place-n.4th Copy a string several times to a string variable.

prng.4th Leaves a pseudo random number in the range (0,1) on the 
FP stack.

polys.4th An implementation of Chebyshev, Bessel, Hermite, 
Laguerre and Legendre polynomials.

prefixno.4th Formats prefixed numbers.

print.4th Printing of strings with automatic linebreaks.

qsort.4th An implementation of the qsort() function.

quiz.4th A template for creating and evaluating simple quiz 
programs.

quotes.4th Removes leading and trailing quotes from a string.

ramdisk.4th An implementation of a simple RAM disk.

randbin.4th Generates random binary patterns.

randmwcp.4th An implementation of a ”Multiply With Carry” random 
number generator.

random.4th Simple linear congruential random number generators.

randoom.4th An exact copy of the ”Doom” random number generator.

range.4th WITHIN, BETWEEN

rcheck.4th Checks if the Return Stack is balanced.

rdepth.4th DEPTH and .S like words for the return stack.

replace.4th Several words for replacing and deleting substrings 
within strings.

represnt.4th REPRESENT

reverse.4th An implementation of the strrev() function.

rot13.4th An implementation of the ROT13 function.

row.4th A library for searching lookup tables.

savefile.4th SAVE-INPUT and RESTORE-INPUT like words for files.

say.4th An interface to the Festival library.

sbreak.4th An implementation of the strpbrk() function.

scanfile.4th A library for quickly skipping to a predefined 
position in a text file.

scanskip.4th An implementation of the COMUS string tokenizing 
words SKIP, SCAN and SPLIT.

scomma.4th Add thousands separator to a decimal numeric string.

search.4th SEARCH

sel2sort.4th An implementation of the selection sort algorithm.

selcsort.4th An implementation of the selection sort algorithm.

sha1.4th A port of the FFL ”SHA-1 checksum” module.

sha256.4th A port of the FFL ”SHA-2 checksum” module.

shelsort.4th An implementation of the Shell sort algorithm.

shuffle.4th A library for shuffling character and numeric arrays.

simpsort.4th An implementation of the simple sort algorithm.

sinhcosh.4th FSINH, FCOSH, FTANH

slice.4th Several string slicing words.

slowsort.4th An implementation of the slow sort algorithm.

soundex.4th An implementation of the SOUNDEX function.

speak.4th An interface to the eSpeak library.

spelldis.4th An implementation of a simple ”spelling distance” 
algorithm.

split.4th The TOOLBELT implemention of the string splitting words 
/SPLIT and -SPLIT.

srtstack.4th Sorts the Data Stack.

stack.4th An implementation of user-defined stacks.

startend.4th The TOOLBELT implemention of the string comparison 
words STARTS? and ENDS?.

statist.4th Several floating point statistical functions.

stemleaf.4th A library for plotting stem-leaf diagrams.

stester.4th A small library by Josh Grams for testing Forth 
words.

stmstack.4th An implementation of a single string stack with 
error detection.

stoosort.4th An implementation of the stooge sort algorithm.

strbuf.4th A library for creating and managing string buffers.

strcount.4th Counts the number of certain substrings in a string.

strstack.4th An implementation of a string stack using a circular 
buffer.

stsstack.4th An implementation of a true string stack.

substit.4th REPLACES, SUBSTITUTE, UNESCAPE

swapping.4th Exchanges one character in a string for another.

system.4th An implementation of the system() function.

tabs.4th Converts tabs in strings to spaces and vice versa.

taylor.4th A library for creating approximation functions using 
Taylor series.

tea.4th An implementation of the TEA encryption algorithm.

tean.4th An implementation of the TEA New encryption algorithm.

termansi.4th Several ANSI Terminal words.

threevl.4th An implementation of ”three value logic”.

throw.4th Several THROW constants.

throwstr.4th Converts a THROW code to a string.

th-word.4th The TOOLBELT implemention of the substring extraction 
words TH-WORD and TH-WORD-BACK.

time.4th Several time and date related words.

timer.4th Words for measuring execution times.

toarabic.4th Converts Roman numerals to Arabic numerals.

todate.4th Recognizes, parses and converts date strings.

todbl.4th >NUMBER

tokenize.4th A library for tokenizing strings.

tonumber.4th >NUMBER

toolbelt.4th Some well known TOOLBELT words.

toolfile.4th Some TOOLBELT inspired, contextless I/O words.

toroman.4th Converts Arabic numerals to Roman numerals.

translat.4th An implementation of the PHP strtr() function.

trim.4th The TOOLBELT implemention of the string leading and 
trailing whitespace stripping words.

tst.4th A port of the FFL test module.

ttester.4th A library for testing Forth words.

ulcase.4th Converts strings and characters from upper case to 
lower case and vice versa.

unicdgbk.4th Converts Chinese Unicode characters to GBK/2.

unitconv.4th Converts imperial units to SI units and vice versa.

userpad.4th An implementation of a user-defined circular string 
buffer.

ustodate.4th Converts a large number of "Month Day Year" strings 
to day, month, year format.

utf8.4th An implementation of the UTF-8 codec.

utf8gbk2.4th An UTF-8 to GBK/2 characterset conversion.

utf8type.4th An implementation of TYPE with built-in ISO-8859 to 
UTF8 conversion.

version.4th A word returning the 4tH version as a string.

vmem.4th Allocates variables, strings and arrays in blockfiles.

westhtml.4th A CP437 and ISO-8859 Western characterset HTML 
conversion.

wildcard.4th A word for comparing strings using wildcards.

word.4th WORD

xchar.4th X-SIZE, XC-SIZE, XC@+, XC!+, XC!+?, XCHAR+, XEMIT, 
-TRAILING-GARBAGE, X-WIDTH, XHOLD, XC-WIDTH, +X/STRING , 
X\STRING-, XCHAR-

yesno.4th A library with vectors for inverting words.

yesorno.4th Get a 'yes' or 'no' answer from the console and 
return a flag.

yield.4th An implementation of generator-type coroutines.

zenans.4th FROT, FOVER, FDUP, FSWAP, FDROP, F@, F!, FLOATS, 
PRECISION, SET-PRECISION

zenatan2.4th FATAN2

zenatanh.4th FASINH, FACOSH, FATANH

zencart.4th Cartesian to polar coordinates conversion.

zendegrd.4th Degrees to radians conversion (and vice versa).

zenexpm1.4th FEXPM1

zenfalog.4th F**, FALOG

zenfasin.4th FATAN, FASIN, FACOS

zenfcbrt.4th An implementation of the floating point cube root 
function.

zenferf.4th An implementation of the erf() function.

zenfexp.4th FEXP

zenfln.4th FLN, FLOG

zenflnp1.4th FLNP1

zenfloat.4th FLOAT, FLOAT+, F+, FNEGATE, F-, FABS, F*, F/, F0=, 
F0<, F<, F=, D>F

zenfloor.4th FLOOR

zenfmin.4th FMIN, FMAX

zenfpio.4th >FLOAT, F.

zenfprox.4th F~

zenfsin.4th FSIN, FCOS, FTAN, FSINCOS

zenfsinh.4th FSINH, FCOSH, FTANH

zenfsqrt.4th FSQRT, F2/

zengamma.4th An implementation of the Gamma function.

zenhaver.4th An implementation of the haversine formula.

zenhornr.4th An implementation for evaluation of a polynomial by 
the Horner method.

zenpolar.4th Polar to Cartesian coordinates conversion.

zenround.4th FROUND

zentaylr.4th A library for creating approximation functions using 
Taylor series.

zentodbl.4th F>D

zentrunc.4th FTRUNC, FCEIL

zxrandom.4th An exact copy of the Sinclair ZX Spectrum floating 
point random number generator.

23.2 Library dependencies<cha:Library-dependencies>

Here all mixed, double and floating point library files and their 
dependencies are listed. If only one of the listed files is 
needed resolve a dependency, they are printed in italics. 


+---------------+----------+---------------+
| Library       | Family   | Depends on    |
+---------------+----------+---------------+
+---------------+----------+---------------+
| ansdbl.4th    |          | anscore.4th   |
|               |          | constant.4th  |
+---------------+----------+---------------+
| ansfloat.4th  | ANS      | mixed.4th     |
+---------------+----------+---------------+
| ansfpio.4th   | ANS      | ansfloat.4th  |
|               |          | dblsharp.4th  |
+---------------+----------+---------------+
| asinacos.4th  | ANS      | fpconst.4th   |
|               |          | taylor.4th    |
+---------------+----------+---------------+
| chi2.4th      | ANS/Zen  | ansfloat.4th  |
|               |          | zenans.4th    |
+---------------+----------+---------------+
| dblbin.4th    |          | ansdbl.4th    |
+---------------+----------+---------------+
| dbldiv.4th    |          | mixed.4th     |
+---------------+----------+---------------+
| dbldot.4th    |          | dblsharp.4th  |
+---------------+----------+---------------+
| dblsharp.4th  |          | mixed.4th     |
+---------------+----------+---------------+
| ddigroot.4th  |          | mixed.4th     |
+---------------+----------+---------------+
| dsqrt.4th     |          | mixed.4th     |
+---------------+----------+---------------+
| ellipint.4th  | ANS      | flnflog.4th   |
|               |          | horner.4th    |
+---------------+----------+---------------+
| erf.4th       | ANS      | fexp.4th      |
|               |          | fequals.4th   |
+---------------+----------+---------------+
| erf1.4th      | ANS      | fexp.4th      |
+---------------+----------+---------------+
| erf1.4th      | Zen      | zenans.4th    |
|               |          | zenfexp.4th   |
+---------------+----------+---------------+
| expout.4th    | ANS/Zen  | fpdot.4th     |
+---------------+----------+---------------+
| falog.4th     | ANS      | fexp.4th      |
|               |          | flnflog.4th   |
+---------------+----------+---------------+
| fatan2.4th    | ANS      | asinacos.4th  |
+---------------+----------+---------------+
| fatanh.4th    | ANS      | flnflog.4th   |
+---------------+----------+---------------+
| fbeta.4th     | ANS      | gammaln.4th   |
|               |          | fexp.4th      |
+---------------+----------+---------------+
| fbetacdf.4th  | ANS      | gammaln.4th   |
|               |          | fexp.4th      |
+---------------+----------+---------------+
| fbetapdf.4th  | ANS      | fbeta.4th     |
|               |          | falog.4th     |
+---------------+----------+---------------+
| fcartes.4th   | ANS      | asinacos.4th  |
+---------------+----------+---------------+
| fcbrt.4th     | ANS      | ansfloat.4th  |
+---------------+----------+---------------+
| fdeg2rad.4th  | ANS/Zen  | fpconst.4th   |
+---------------+----------+---------------+
| felip.4th     | ANS      | ansfloat.4th  |
|               |          | fpconst.4th   |
+---------------+----------+---------------+
| fequals.4th   | ANS/Zen  | ansfloat.4th  |
|               |          | zenans.4th    |
+---------------+----------+---------------+
| fenter.4th    | ANS/Zen  | ansfpio.4th   |
|               |          | zenfpio.4th   |
|               |          | fpin.4th      |
+---------------+----------+---------------+
| ferf.4th      | ANS      | fpconst.4th   |
|               |          | taylor.4th    |
+---------------+----------+---------------+
| fexp.4th      | ANS      | fpconst.4th   |
|               |          | fpow.4th      |
+---------------+----------+---------------+
| fexpt.4th     | ANS      | fpconst.4th   |
|               |          | taylor.4th    |
+---------------+----------+---------------+
| fexpint.4th   | ANS      | fexp.4th      |
|               |          | flnflog.4th   |
+---------------+----------+---------------+
| fexpm1.4th    | ANS      | fexp.4th      |
+---------------+----------+---------------+
| fhaversn.4th  | ANS      | fsinfcos.4th  |
|               |          | asinacos.4th  |
|               |          | fdeg2rad.4th  |
+---------------+----------+---------------+
| flnflog.4th   | ANS      | frexp.4th     |
|               |          | ansfpio.4th   |
|               |          | fpin.4th      |
+---------------+----------+---------------+
| flnflogb.4th  | ANS      | ansfloat.4th  |
|               |          | fpconst.4th   |
|               |          | fpow10.4th    |
+---------------+----------+---------------+
| flnp1.4th     | ANS      | flnflog.4th   |
+---------------+----------+---------------+
| flogist.4th   | ANS      | fexp.4th      |
+---------------+----------+---------------+
| forwdiff.4th  | ANS/Zen  | ansfloat.4th  |
|               |          | zenans.4th    |
+---------------+----------+---------------+
| fp0.4th       | Zen      | zenfloat.4th  |
|               |          | zenfpio.4th   |
+---------------+----------+---------------+
| fp1.4th       | Zen      | zenfloat.4th  |
|               |          | zenfpio.4th   |
|               |          | zenans.4th    |
+---------------+----------+---------------+
| fp2.4th       | Zen      | zenfloat.4th  |
|               |          | zenans.4th    |
|               |          | fpin.4th      |
|               |          | fpout.4th     |
+---------------+----------+---------------+
| fp3.4th       | ANS      | ansfloat.4th  |
|               |          | ansfpio.4th   |
+---------------+----------+---------------+
| fp4.4th       | ANS      | ansfloat.4th  |
|               |          | fpin.4th      |
|               |          | fpout.4th     |
+---------------+----------+---------------+
| fpdot.4th     | ANS/Zen  | ansfloat.4th  |
|               |          | zenans.4th    |
+---------------+----------+---------------+
| fpconst.4th   | ANS/Zen  | ansfpio.4th   |
|               |          | fpin.4th      |
+---------------+----------+---------------+
| fpin.4th      | ANS/Zen  | tonumber.4th  |
|               |          | ansfloat.4th  |
|               |          | zenans.4th    |
+---------------+----------+---------------+
| fpolar.4th    | ANS      | fsinfcos.4th  |
+---------------+----------+---------------+
| fpout.4th     | ANS/Zen  | range.4th     |
|               |          | represnt.4th  |
+---------------+----------+---------------+
| fpow.4th      | ANS      | ansfloat.4th  |
+---------------+----------+---------------+
| fpow10.4th    | ANS/Zen  | ansfloat.4th  |
|               |          | zenfloat.4th  |
+---------------+----------+---------------+
| fq.4th        | ANS      | ferf.4th      |
+---------------+----------+---------------+
| fracout.4th   | ANS/Zen  | fpdot.4th     |
+---------------+----------+---------------+
| frexp.4th     | ANS      | ansfloat.4th  |
+---------------+----------+---------------+
| fsinfcos.4th  | ANS      | fpconst.4th   |
+---------------+----------+---------------+
| fsincost.4th  | ANS      | fpconst.4th   |
|               |          | taylor.4th    |
+---------------+----------+---------------+
| fsl-util.4th  | ANS      | ansfpio.4th   |
|               |          | fpout.4th     |
+---------------+----------+---------------+
| ftrunc.4th    | ANS      | ansfloat.4th  |
+---------------+----------+---------------+
| fvector.4th   | ANS      | ansfloat.4th  |
+---------------+----------+---------------+
| fzeta.4th     | ANS      | falog.4th     |
+---------------+----------+---------------+
| gamma.4th     | ANS      | fequals.4th   |
|               |          | fexp.4th      |
|               |          | flnflog.4th   |
|               |          | fsinfcos.4th  |
|               |          | horner.4th    |
+---------------+----------+---------------+
| gammaln.4th   | ANS      | flnflog.4th   |
|               |          | fpow10.4th    |
+---------------+----------+---------------+
| gammapq.4th   | ANS      | gammaln.4th   |
|               |          | fexp.4th      |
+---------------+----------+---------------+
| gauss.4th     | ANS      | horner.4th    |
+---------------+----------+---------------+
| horner.4th    | ANS      | fsl-util.4th  |
+---------------+----------+---------------+
| mbinoml.4th   |          | mixed.4th     |
+---------------+----------+---------------+
| mixed.4th     |          | ansdbl.4th    |
+---------------+----------+---------------+
| norm-pdf.4th  | ANS      | fexp.4th      |
+---------------+----------+---------------+
| pcylfun.4th   | ANS      | falog.4th     |
|               |          | fpow10.4th    |
|               |          | gamma.4th     |
+---------------+----------+---------------+
| permcomb.4th  |          | mixed.4th     |
+---------------+----------+---------------+
| polys.4th     | ANS      | ansfloat.4th  |
+---------------+----------+---------------+
| prng.4th      | ANS/Zen  | ansfloat.4th  |
|               |          | zenans.4th    |
+---------------+----------+---------------+
| represnt.4th  | ANS/Zen  | dbldot.4th    |
|               |          | ansfloat.4th  |
|               |          | zenans.4th    |
+---------------+----------+---------------+
| sinhcosh.4th  | ANS      | fexpm1.4th    |
+---------------+----------+---------------+
| statist.4th   | ANS      | falog.4th     |
+---------------+----------+---------------+
| statist.4th   | Zen      | zenfsqrt.4th  |
|               |          | zenans.4th    |
|               |          | zenfalog.4th  |
+---------------+----------+---------------+
| taylor.4th    | ANS      | ansfloat.4th  |
+---------------+----------+---------------+
| todbl.4th     |          | digit.4th     |
|               |          | mixed.4th     |
+---------------+----------+---------------+
| tonumber.4th  |          | digit.4th     |
+---------------+----------+---------------+
| zenans.4th    | Zen      | zenround.4th  |
|               |          | zentodbl.4th  |
+---------------+----------+---------------+
| zenatan2.4th  | Zen      | zenfasin.4th  |
+---------------+----------+---------------+
| zenatanh.4th  | Zen      | zenfln.4th    |
|               |          | zenfsqrt.4th  |
+---------------+----------+---------------+
| zencart.4th   | Zen      | zenfasin.4th  |
|               |          | zenfsqrt.4th  |
+---------------+----------+---------------+
| zendegrd.4th  | Zen      | zenfloat.4th  |
+---------------+----------+---------------+
| zenexpm1.4th  | Zen      | zenfexp.4th   |
+---------------+----------+---------------+
| zenfalog.4th  | Zen      | zenfexp.4th   |
|               |          | zenfln.4th    |
+---------------+----------+---------------+
| zenfasin.4th  | Zen      | zenfsqrt.4th  |
|               |          | zentaylr.4th  |
+---------------+----------+---------------+
| zenfcbrt.4th  | Zen      | zenfsqrt.4th  |
+---------------+----------+---------------+
| zenferf.4th   | Zen      | zentaylr.4th  |
+---------------+----------+---------------+
| zenfexp.4th   | Zen      | zentaylr.4th  |
|               |          | zentrunc.4th  |
+---------------+----------+---------------+
| zenfln.4th    | Zen      | zenfloat.4th  |
+---------------+----------+---------------+
| zenflnp1.4th  | Zen      | zenfln.4th    |
+---------------+----------+---------------+
| zenfloat.4th  | Zen      | mixed.4th     |
+---------------+----------+---------------+
| zenfloor.4th  | Zen      | zenfloat.4th  |
+---------------+----------+---------------+
| zenfmin.4th   | Zen      | zenfloat.4th  |
+---------------+----------+---------------+
| zenfpio.4th   | Zen      | (none)        |
+---------------+----------+---------------+
| zenfprox.4th  | Zen      | zenfloat.4th  |
+---------------+----------+---------------+
| zenfsin.4th   | Zen      | zenfloor.4th  |
|               |          | zentaylr.4th  |
+---------------+----------+---------------+
| zenfsinh.4th  | Zen      | zenexpm1.4th  |
+---------------+----------+---------------+
| zenfsqrt.4th  | Zen      | zenfloat.4th  |
+---------------+----------+---------------+
| zengamma.4th  | Zen      | zenfsqrt.4th  |
|               |          | zenfalog.4th  |
+---------------+----------+---------------+
| zenhaver.4th  | Zen      | zenfsin.4th   |
|               |          | zenfasin.4th  |
|               |          | zenfsqrt.4th  |
|               |          | zendegrd.4th  |
+---------------+----------+---------------+
| zenhornr.4th  | Zen      | zenfloat.4th  |
+---------------+----------+---------------+
| zenpolar.4th  | Zen      | zenfsin.4th   |
|               |          | zenround.4th  |
+---------------+----------+---------------+
| zenround.4th  | Zen      | zentrunc.4th  |
+---------------+----------+---------------+
| zentaylr.4th  | Zen      | zenfloat.4th  |
+---------------+----------+---------------+
| zentodbl.4th  | Zen      | zenfloat.4th  |
+---------------+----------+---------------+
| zentrunc.4th  | Zen      | zenfloor.4th  |
+---------------+----------+---------------+
| zxrandom.4th  | ANS/Zen  | ansfloat.4th  |
|               |          | zenfloat.4th  |
+---------------+----------+---------------+

